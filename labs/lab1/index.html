<!DOCTYPE html>
    <html lang="en">
      <head><link rel="stylesheet" type="text/css" href="/website-fall-23/assets/index.456f6971.css">
        <meta charset="UTF-8">
        <title>Lab 1 | CSCI 1230</title>
        <meta name="description" content="We teach computer graphics!">
        <meta name="keywords" content="Computer Science, Computer Graphics, CS 1230, CSCI 1230, Brown University, Providence">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-263NEZCW0C"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-263NEZCW0C');
        </script>
      </head>
      <body>
        <div id="root">
          <nav id="nav-bar"><div id="nav-bar-inner"><a id="logo" class="no-select" href="/website-fall-23/" aria-label="home" style="--duration:450ms"><div id="logo-box-1"></div><div id="logo-box-2"></div><div id="logo-box-3"></div><div id="logo-box-4"></div><div id="logo-box-5"></div><div id="logo-box-6"></div></a><div id="nav-items"><div id="nav-items-inner"><a href="/website-fall-23/" class="nav-item">Home</a><a href="/website-fall-23/docs" class="nav-item">Docs</a><a href="/website-fall-23/lectures" class="nav-item">Lectures</a><a href="/website-fall-23/labs" class="nav-item">Labs</a><a href="/website-fall-23/projects" class="nav-item">Projects</a></div></div></div></nav><div id="page" class=""><nav class="toc"><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#lab-1-setup--c">Lab 1: Setup &amp; C++</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#introduction">Introduction</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#objectives">Objectives</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#getting-started">Getting Started</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#qt-and-qt-creator">Qt and Qt Creator</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#installation">Installation</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#setting-your-build-directory">Setting your build directory</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#opening-a-project">Opening a Project</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#using-qt-creator">Using Qt Creator</a><ol class="toc-level toc-level-4"><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#sidebar-view">Sidebar View</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#project-settings">Project Settings</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#running-your-project">Running Your Project</a></li></ol></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#c">C++</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#hello-world">Hello World</a><ol class="toc-level toc-level-4"><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#include-ing-files">#Include-ing Files</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#accessing-things-in-a-namespace">Accessing Things in a Namespace</a></li></ol></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#primitive-types">Primitive Types</a><ol class="toc-level toc-level-4"><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#variables">Variables</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#functions">Functions</a><ol class="toc-level toc-level-5"><li class="toc-item toc-item-h5"><a class="toc-link toc-link-h5" href="#overloading">Overloading</a></li><li class="toc-item toc-item-h5"><a class="toc-link toc-link-h5" href="#generic-functions">Generic Functions</a></li><li class="toc-item toc-item-h5"><a class="toc-link toc-link-h5" href="#extra-lambdas">Extra: Lambdas</a></li></ol></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#a-warning-about-type-deduction">A Warning About Type Deduction</a></li></ol></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#structs-and-classes">Structs and Classes</a><ol class="toc-level toc-level-4"><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#generic-functions-reprise">Generic Functions (Reprise)</a></li></ol></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#other-standard-library-utilities">Other Standard Library Utilities</a><ol class="toc-level toc-level-4"><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#arrays">Arrays</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#vectors">Vectors</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#tuples">Tuples</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#strings">Strings</a></li><li class="toc-item toc-item-h4"><a class="toc-link toc-link-h4" href="#iterating-over-containers">Iterating Over Containers</a></li></ol></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#pointers-and-references">Pointers and References</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#debugging">Debugging</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#end">End</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#submission">Submission</a></li></ol></li></ol></nav><main>
<!-- -->
<h1 id="lab-1-setup--c"><a href="#lab-1-setup--c">Lab 1: Setup &amp; C++</a></h1>
<p><a href="https://classroom.github.com/a/yo8bDyL2" target="_blank" rel="noopener noreferrer">Github Classroom assignment</a></p>
<div class="task-no-number-callout callout"><p>Please put your answers to written questions in this lab, if any, in a Markdown file named <code>README.md</code> in your lab repo.</p></div>
<h2 id="introduction"><a href="#introduction">Introduction</a></h2>
<p>Welcome to CS 1230!</p>
<p>The purpose of this lab is twofold: to set you up with what you&#x27;ll need to work on assignments locally, and to ease you into C++, the programming language we&#x27;ll be using in this course.</p>
<p>If you have any questions or run into any issues, please let us know over Ed or during TA hours. We&#x27;ll do our best to help!</p>
<h3 id="objectives"><a href="#objectives">Objectives</a></h3>
<ol>
<li>Complete our <strong>Getting Started</strong> form,</li>
<li>Install <strong>Qt</strong> &amp; <strong>Qt Creator</strong> locally on your computer,</li>
<li>Build and run a <strong>starter Qt program</strong> using the Qt Creator IDE, and</li>
<li>Learn about the <strong>basics</strong> (and <strong>subtleties</strong>) of <strong>C++</strong>.</li>
</ol>
<h2 id="getting-started"><a href="#getting-started">Getting Started</a></h2>
<p>We assume that you&#x27;re already familiar with using <strong>Github Classroom</strong> to accept assignments, <strong>Ed</strong> to ask questions, and <strong>Gradescope</strong> to submit work.
If you need a refresher on any of this, check out <a href="/website-fall-23/docs/github-gradescope-guide">this page</a>.</p>
<p><strong>Please fill out <a href="https://forms.gle/YUhDT5XjCAW1zuvn7" target="_blank" rel="noopener noreferrer">our Getting Started form</a> as you complete the steps below:</strong></p>
<ol>
<li>Read our course&#x27;s <a href="/website-fall-23/docs/collaboration-policy">collaboration policy</a>,</li>
<li>Join the CS 1230 <a href="https://edstem.org/us/join/z44edc" target="_blank" rel="noopener noreferrer">Ed discussion page</a></li>
<li>Enroll in this course over on <a href="http://www.gradescope.com/" target="_blank" rel="noopener noreferrer">Gradescope</a> using our entry code, <code>E788WB</code>,</li>
<li>Accept this lab&#x27;s assignment from <a href="https://classroom.github.com/a/yo8bDyL2" target="_blank" rel="noopener noreferrer">Github Classroom</a>, and</li>
<li>Clone the resulting repository to your local machine.</li>
</ol>
<p>At this point, you should have a copy of this lab&#x27;s repository. All set? Let&#x27;s get started!</p>
<h2 id="qt-and-qt-creator"><a href="#qt-and-qt-creator">Qt and Qt Creator</a></h2>
<p>In CS 1230, we will be using <strong>Qt</strong> and <strong>Qt Creator</strong> to develop, build, and run all our projects and labs. Before we walk you through how to install them to your local machine, here&#x27;s a brief description of each:</p>
<ul>
<li><strong><a href="https://www.qt.io" target="_blank" rel="noopener noreferrer">Qt</a></strong> is a software used for building graphical user interfaces (GUIs) and cross-platform applications, e.g. for smart TVs or in-vehicle displays.</li>
<li><strong><a href="https://www.qt.io/product/development-tools" target="_blank" rel="noopener noreferrer">Qt Creator</a></strong> is an integrated development environment (IDE) included with each Qt install. It provides useful tools for developing in C++, which you&#x27;ll learn about later in the course.</li>
</ul>
<blockquote>
<p><strong>We will be using Qt 6.5</strong>, which is the latest <a href="https://en.wikipedia.org/wiki/Long-term_support" target="_blank" rel="noopener noreferrer">long-term support</a> version.
As for <strong>Qt <em>Creator</em></strong>, any version is fineâ€”it&#x27;d be easiest to just use the one that comes with your Qt install.</p>
</blockquote>
<details><summary>But I&#x27;d rather work in <strong>VS Code / Emacs / Notepad++ / etc</strong>, instead of in <strong>Qt Creator</strong>!</summary><p>If you know what you&#x27;re doing, you may certainly write code in your IDE of choice. In the past, students have successfully used other IDEs for writing code, before using Qt Creator to build and run their projects.</p><p>That being said, the CS 1230 course staff are not obligated to provide support for other IDEs and, if needed, will build and run your code with Qt Creator. Thus, you&#x27;ll probably want to install Qt Creator anyway, if only to test that your code works as expected when running with it.</p></details>
<h3 id="installation"><a href="#installation">Installation</a></h3>
<div class="success-callout callout"><p>If you&#x27;re using a <strong>department machine</strong>, skip this section. Simply open a terminal and run the following to open Qt Creator:</p><pre><code class="code-highlight"><span class="code-line">qtcreator
</span></code></pre></div>
<div class="warning-callout callout"><p>Qt and Qt Creator will take up ~3GB of space in total.</p></div>
<div class="error-callout callout"><details><summary><strong>Warning for students using macOS</strong></summary><p>Before start installing Qt, please first use the following command to check whether you have Xcode or the Xcode Command Line Tools installed.</p><pre><code class="code-highlight"><span class="code-line">xcode-select -p
</span></code></pre><p>If your console outputs either of the following, which means that you have already installed some version of Xcode, you are good to continue.</p><pre><code class="code-highlight"><span class="code-line">/Applications/Xcode.app/Contents/Developer
</span></code></pre><pre><code class="code-highlight"><span class="code-line">/Library/Developer/CommandLineTools
</span></code></pre><p>Otherwise, please follow our <a href="/website-fall-23/docs/xcode-CLT-installation-guide">Xcode CLT Installation Guide</a> before proceeding.</p></details></div>
<div class="table-wrapper"><table><thead><tr><th align="left"><div style="min-width:350px">Instruction</div></th><th align="left">Screenshot (click to expand)</th></tr></thead><tbody><tr><td align="left"><strong>Download</strong> and open the appropriate Qt installer for your operating system from <a href="https://www.qt.io/download-qt-installer" target="_blank" rel="noopener noreferrer">the Qt installer page</a>.</td><td align="left"><a href="/website-fall-23/labs/lab1/download-qt-installer.png"><img src="/website-fall-23/labs/lab1/download-qt-installer.png" alt="todo"/> </a></td></tr><tr><td align="left">Follow the instructions on the installer to <strong>create a free Qt account</strong> (or use an existing one).</td><td align="left"><a href="/website-fall-23/labs/lab1/create-qt-account.png"><img src="/website-fall-23/labs/lab1/create-qt-account.png" alt="todo"/> </a></td></tr><tr><td align="left">When prompted, <strong>opt for a <code>Custom Installation</code></strong>.</td><td align="left"><a href="/website-fall-23/labs/lab1/custom-installation.png"><img src="/website-fall-23/labs/lab1/custom-installation.png" alt="todo"/> </a></td></tr><tr><td align="left">On the next page, <strong>select (at least) these four</strong>:<br/><br/>1. <code>Qt 6.5.2 &gt; MinGW [...]</code> (Windows) or <code>Qt 6.5.2 &gt; macOS</code> (macOS),<br/>2. <code>Dev. and Designer Tools &gt; Qt Creator</code><br/>3. <code>Dev. and Designer Tools &gt; CMake</code><br/>4. <code>Dev. and Designer Tools &gt; Ninja</code><br/><br/>Note: you may opt to install more components, but be warned that this will take up a lot more space on your machine!</td><td align="left"><a href="/website-fall-23/labs/lab1/selected-components.png"><img src="/website-fall-23/labs/lab1/selected-components.png" alt="todo"/> </a></td></tr><tr><td align="left">Proceed with the installation. Once finished, <strong>launch Qt Creator</strong>.</td><td align="left"><a href="/website-fall-23/labs/lab1/finished-install.png"><img src="/website-fall-23/labs/lab1/finished-install.png" alt="todo"/> </a></td></tr></tbody></table></div>
<h3 id="setting-your-build-directory"><a href="#setting-your-build-directory">Setting your build directory</a></h3>
<p>By default, when you build and run your projects, Qt Creator will create the build output in the parent directory of your project directory. For example, if we had this Lab 1 project at <code>/Users/jo/cs1230/lab01-setup-cpp-jo</code>, Qt Creator would place the build directory at <code>/Users/jo/cs1230/build-lab01-setup-cpp-jcarberry...</code> by default.
For some of the projects we have in this course, this structure can be somewhat inconvenient or hard to work with, so instead we opt for a format where all builds live inside a <code>build</code> folder inside the project directory. So, for the <code>lab01</code> project, we&#x27;d have the following structure:</p>
<pre><code class="code-highlight"><span class="code-line">âˆŸ lab01-setup-cpp-[your GitHub username]/ (project directory)
</span><span class="code-line">  âˆŸ build/ (all build output goes here)
</span><span class="code-line">    âˆŸ build-[project name]-[Qt kit name]-[build configuration]/ (a build directory)
</span><span class="code-line">      âˆŸ lab01 (the executable)
</span><span class="code-line">      âˆŸ [other build files]
</span><span class="code-line">  âˆŸ src/
</span><span class="code-line">  âˆŸ CMakeLists.txt
</span><span class="code-line">  âˆŸ [other files]
</span></code></pre>
<p>In order for Qt Creator to use this structure by default, we need to change a setting in the preferences.</p>
<div class="table-wrapper"><table><thead><tr><th align="left"><div style="min-width:350px">Instruction</div></th><th align="left">Screenshot (click to expand)</th></tr></thead><tbody><tr><td align="left">Open Qt Creator preferences by going to <code>Qt Creator &gt; Preferences...</code> or <code>âŒ˜ + ,</code> (Mac) or <code>Edit &gt; Preferences...</code> (Windows).</td><td align="left"><a href="/website-fall-23/labs/lab1/open-qt-prefs.png"><img src="/website-fall-23/labs/lab1/open-qt-prefs.png" alt="todo"/></a></td></tr><tr><td align="left">Open the <code>Build &amp; Run &gt; Default Build Properties</code>.</td><td align="left"><a href="/website-fall-23/labs/lab1/open-build-prefs.png"><img src="/website-fall-23/labs/lab1/open-build-prefs.png" alt="todo"/></a></td></tr><tr><td align="left">In the <code>Default build directory</code> field, replace the current text with: <code>./%{JS: Util.asciify(&quot;build/build-%{Project:Name}-%{Kit:FileSystemName}-%{BuildConfig:Name}&quot;)}</code>.</td><td align="left"><a href="/website-fall-23/labs/lab1/def-build-dir.png"><img src="/website-fall-23/labs/lab1/def-build-dir.png" alt="todo"/></a></td></tr><tr><td align="left">Click <code>OK</code>.</td><td align="left"><a href="/website-fall-23/labs/lab1/close-qt-prefs.png"><img src="/website-fall-23/labs/lab1/close-qt-prefs.png" alt="todo"/></a></td></tr></tbody></table></div>
<blockquote>
<p>If you have already configured a project in Qt Creator before making this change and the project is not building to within <code>[project_directory]/build</code>, you can reconfigure your project by:</p>
<ol>
<li>Closing the project (File &gt; Close Project ...)</li>
<li>Deleting the <code>CMakeLists.txt.user</code> file in your project directory</li>
<li>Reopening the project (File &gt; Open File or Project...)</li>
</ol>
<p>You will be prompted to configure the project again, and it should now build to the correct directory.</p>
</blockquote>
<h3 id="opening-a-project"><a href="#opening-a-project">Opening a Project</a></h3>
<div class="table-wrapper"><table><thead><tr><th align="left"><div style="min-width:350px">Instruction</div></th><th align="left">Screenshot (click to expand)</th></tr></thead><tbody><tr><td align="left">In the Qt Creator application, click <code>Open Project</code>. In the file browser that appears, <strong>choose the <code>CMakeLists.txt</code> file</strong> located in your copy of this lab&#x27;s repository.</td><td align="left"><a href="/website-fall-23/labs/lab1/open-project.png"><img src="/website-fall-23/labs/lab1/open-project.png" alt="todo"/></a></td></tr><tr><td align="left">You will then be asked to select a kit. If there are multiple options, select the one that has <strong>6.5.2</strong> in the title. Expand the <em>details</em> dropdown on the right and make sure that, <em>at least</em>, the <strong>Debug</strong> and <strong>Release</strong> options are selected.</td><td align="left"><a href="/website-fall-23/labs/lab1/select-kit.png"><img src="/website-fall-23/labs/lab1/select-kit.png" alt="todo"/></a></td></tr></tbody></table></div>
<p>After that, you should be taken to the Edit tab!</p>
<h3 id="using-qt-creator"><a href="#using-qt-creator">Using Qt Creator</a></h3>
<h4 id="sidebar-view"><a href="#sidebar-view">Sidebar View</a></h4>
<p>In the left sidebar, Qt Creator displays content based on the currently-selected &#x27;sidebar view&#x27;. The two views you&#x27;ll find mose useful are the <code>Projects</code> and <code>File System</code> views. <code>Projects</code> view shows a list of projects open in the current session, and the source, header, and other files for each; meanwhile, <code>File System</code> view shows all files in the currently selected directory.</p>
<p>We recommend using the <code>Projects</code> view most of the time! You can switch views by clicking on the dropdown menu at the top.</p>
<figure id="figure-1" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><a href="/website-fall-23/labs/lab1/project-view.png" target="_blank" rel="noopener noreferrer"><img src="/labs/lab1/project-view.png" alt="TODO"/></a><a href="/website-fall-23/labs/lab1/file-system-view.png" target="_blank" rel="noopener noreferrer"><img src="/labs/lab1/file-system-view.png" alt="TODO"/></a></div><figcaption><strong>Figure 1: </strong>Projects view vs File System view</figcaption></figure>
<h4 id="project-settings"><a href="#project-settings">Project Settings</a></h4>
<p>To modify the currently-selected project&#x27;s settings, click &#x27;Projects&#x27; on the left-most sidebar of your screen. These settings are divided into &#x27;build&#x27; and &#x27;run&#x27; settings.</p>
<p>In <strong>run</strong> settings, you can edit your <strong>command line arguments</strong>, which will be important for later assignments. For now, the most important setting you can edit here is your <strong>working directory</strong>.</p>
<div class="success-callout callout"><p>For all assignments in CS 1230, you should always change your working directory to the parent folder of your project&#x27;s <code>CMakeLists.txt</code>.</p><figure id="figure-2" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><a href="/website-fall-23/labs/lab1/working-directory.png" target="_blank" rel="noopener noreferrer"><img src="/labs/lab1/working-directory.png" alt="TODO"/></a></div><figcaption><strong>Figure 2: </strong>Always remember to set your working directory!</figcaption></figure><details><summary>Extra: what is the significance of the working directory?</summary><p>C++ is a compiled language, so an executable is produced at the end of the build process. <strong>The working directory is the directory from which this executable will be run.</strong></p><p>Two important points follow:</p><ol>
<li>This executable will be generated in a <em>new</em> <strong>build directory</strong>, which will be a &quot;sibling&quot; of your project&#x27;s <em>source directory</em>. For example:</li>
</ol><pre><code class="language-text code-highlight"><span class="code-line highlight-line">âˆŸ build-lab01_setup_cpp_ghusername-&lt;kit-name&gt;-Release/ (build directory)
</span><span class="code-line highlight-line">  âˆŸ lab01                                              (the executable)
</span><span class="code-line">âˆŸ lab01-setup-cpp-ghusername/                          (source directory)
</span><span class="code-line">  âˆŸ CMakeLists.txt                                     (the file you opened in Qt Creator)
</span><span class="code-line">  âˆŸ src/
</span><span class="code-line">  âˆŸ resources/
</span><span class="code-line">    âˆŸ images/
</span></code></pre><ol start="2">
<li>By default, your project&#x27;s working directory will be set to this build directory.</li>
</ol><p>This is a problem because your application might try to access files using a <strong>file path</strong> relative to the <em>source</em> directory, but incorrectly looks for those files relative to the <em>build</em> directory.</p></details></div>
<p>Meanwhile, in <strong>build</strong> settings, you can select your <a href="https://doc.qt.io/qtcreator/creator-build-settings.html" target="_blank" rel="noopener noreferrer"><strong>build configuration</strong></a> from <code>Debug</code>, <code>Release</code>, and (possibly) others. A <code>Debug</code> build contains additional information internally that will be important if you&#x27;re using the debugger, whereas a <code>Release</code> build is optimized to run faster.</p>
<p>We recommend using the <code>Release</code> configuration for all non-debugging work. Note that you can set the build configuration using a dropdown on the bottom left:</p>
<figure id="figure-3" class="image-wrapper"><div class="image-grid" style="--target-width:50%"><a href="/website-fall-23/labs/lab1/release-mode.png" target="_blank" rel="noopener noreferrer"><img src="/labs/lab1/release-mode.png" alt="TODO"/></a></div><figcaption><strong>Figure 3: </strong>Select your build configuration here.</figcaption></figure>
<h4 id="running-your-project"><a href="#running-your-project">Running Your Project</a></h4>
<p>Finally, you can run your project by hitting &quot;Run&quot;; this is the green play button in the above image. This will run your project in whatever build mode is currently selected.</p>
<div class="task-callout callout"><p>When you&#x27;re ready, hit &quot;Run&quot;.</p><p>You should see that the application runs and exits with error code <code>0</code> (no error).</p></div>
<p>You just ran a simple C++ program! Of course, it did nothing, but we can easily change that in the next section ðŸ™‚.</p>
<h2 id="c"><a href="#c">C++</a></h2>
<h3 id="hello-world"><a href="#hello-world">Hello World</a></h3>
<p>A simple C++ program that does nothing (like the one you just ran) looks something like this:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-c">// A C++ program always starts from the main() function.</span>
</span><span class="code-line"><span class="pl-c">// main() returns an integer indicating how the program exited</span>
</span><span class="code-line"><span class="pl-k">int</span> <span class="pl-en">main</span>() {
</span><span class="code-line">  <span class="pl-c">// Though this function body is empty, it still returns an int!</span>
</span><span class="code-line">  <span class="pl-c">// In C++, if control reaches the end of main() without encountering</span>
</span><span class="code-line">  <span class="pl-c">// a return statement, the effect is that of executing `return 0;`</span>
</span><span class="code-line">}
</span></code></pre>
<p>In order to modify this function to print <code>&quot;Hello world&quot;</code>, we must first include the <strong>input/output library</strong> (<code>iostream</code>), which is a part of the <strong>C++ standard library</strong>.</p>
<h4 id="include-ing-files"><a href="#include-ing-files"><code>#Include</code>-ing Files</a></h4>
<p>In C++ files, you can <code>#include</code> other files to gain access to functions, types, macros, and variables declared in those other files. For example, in our Hello World program, we can <code>#include</code> the <code>iostream</code> header file at the top of our <code>main.cpp</code> file like so:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span> <span class="pl-c">// Lines that begin with `#` do not require semi-colons</span>
</span></code></pre>
<blockquote>
<p>Note the use of angle brackets around <code>iostream</code>. In C++, you should use angle brackets for standard library files, but you should use <strong><em>double quotes</em></strong> for files within your own project.</p>
</blockquote>
<details><summary>Extra: how the compiler interprets angle brackets vs. double quotes</summary><p>When you use angle brackets, most compilers will search for the file in the include path list. When you use double quotes, theyâ€™ll first search the local directory (i.e. the directory where the module being compiled is) and only then search the include path list.</p></details>
<h4 id="accessing-things-in-a-namespace"><a href="#accessing-things-in-a-namespace">Accessing Things in a Namespace</a></h4>
<p>Imported functionality is usually grouped under a <code>namespace</code>, and we can access things within a namespace using the double-colon (<code>::</code>) operator. For example, since we included <code>iostream</code> in our Hello World program, we now have access to the following things in the <code>std</code> namespace:</p>
<ul>
<li><code>std::cout</code>: prints things to <code>stdout</code>, i.e. the terminal or the &quot;output&quot; window in Qt Creator.</li>
<li><code>std::endl</code>: inserts a newline character and flushes the output stream.</li>
</ul>
<p><code>std::cout</code> is usually used in tandem with the <a href="https://cplusplus.com/reference/ostream/ostream/operator%3C%3C#example" target="_blank" rel="noopener noreferrer"><em>insertion</em> operator</a> (<code>&lt;&lt;</code>). This inserts characters into the current output stream, and it works like string concatenation with <code>+</code> in some languages.</p>
<p>The insertion operator can also be used with <code>std::endl</code> to insert a newline, in place of <code>\n</code>, the difference being that <code>\n</code> does not flush the output stream.</p>
<div class="task-callout callout"><p>We are now ready to write something to the terminal.</p><ol>
<li>Make sure <code>iostream</code> is included in <code>main.cpp</code>.</li>
<li>In <code>main()</code>, use <code>std::cout</code> and <code>std::endl</code> to print <code>&quot;Hello, world!&quot;</code> to the terminal.</li>
<li>Run your program, and verify that it behaves as expected. Hello, world!</li>
</ol></div>
<details><summary>Extra: two other potentially useful <code>iostream</code> objects</summary><ul>
<li><code>std::cin</code> reads from stdin (terminal input), in a blocking manner, and</li>
<li><code>std::cerr</code> prints to stderr (terminal error messages)</li>
</ul><p><code>std::cin</code> is usually used in tandem with the <a href="https://cplusplus.com/reference/istream/istream/operator%3E%3E/" target="_blank" rel="noopener noreferrer"><em>extraction</em> operator</a> (<code>&gt;&gt;</code>). It&#x27;s highly unlikely that you&#x27;ll use this in CS 1230, though.</p></details>
<p>Now, we can get into the fun stuff!</p>
<h3 id="primitive-types"><a href="#primitive-types">Primitive Types</a></h3>
<p>C++ is a <em>typed</em> language. It comes with several primitive types, including...</p>
<ul>
<li>integer-like types (integers, booleans, characters)</li>
<li>floating point types</li>
<li>arrays (specifically, C-style arrays)</li>
<li>functions and lambdas</li>
<li>pointers and references</li>
</ul>
<p>Some of these you might already know from languages you&#x27;ve learned before. Others, such as pointers and references, are C++ concepts that we&#x27;ll expand on in later sections.</p>
<blockquote>
<p>Note that strings are not a primitive type in C++, as string literals are simply <code>char</code> arrays. However, the standard library does provide the <code>std::string</code> type, which allows us to perform common string operations.</p>
</blockquote>
<h4 id="variables"><a href="#variables">Variables</a></h4>
<p>When defining a variable, we have to <strong>declare</strong> its type.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">int</span> x = <span class="pl-c1">42</span>;
</span><span class="code-line"><span class="pl-k">double</span> y = <span class="pl-c1">3.14</span>;
</span></code></pre>
<p>Alternatively, we may use <code>auto</code> to tell the compiler to <strong>deduce</strong> the variable&#x27;s type, based on how we&#x27;ve initialized it. This could be useful if its type has a very long name, or if we&#x27;re not sure about its exact type.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> z = <span class="pl-c1">2.71</span>; <span class="pl-c">// type of z deduced as double</span>
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// I&#x27;m not exactly sure about the type of this string literal</span>
</span><span class="code-line"><span class="pl-k">auto</span> w = <span class="pl-s"><span class="pl-pds">&quot;</span>random string abcd<span class="pl-pds">&quot;</span></span>;
</span></code></pre>
<h4 id="functions"><a href="#functions">Functions</a></h4>
<p>The same rules also apply to functions: we must declare their return types and the types of each parameter.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">int</span> <span class="pl-en">plusOne</span>(<span class="pl-k">int</span> x) {
</span><span class="code-line">  <span class="pl-k">return</span> x + <span class="pl-c1">1</span>;
</span><span class="code-line">}
</span></code></pre>
<p>Just as with variables, we may use <code>auto</code> in place of a specific return typeâ€”the compiler will deduce the return type from the return statement in the function body.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">plusOne</span>(<span class="pl-k">double</span> x) { <span class="pl-c">// Using auto instead of a specific return type</span>
</span><span class="code-line">  <span class="pl-k">return</span> x + <span class="pl-c1">1</span>;          <span class="pl-c">// Return type deduced as double</span>
</span><span class="code-line">}
</span></code></pre>
<h5 id="overloading"><a href="#overloading">Overloading</a></h5>
<p>Defining multiple functions with the same names, but different type annotations, allows you to do something called <strong><em>overloading</em></strong>, which you might be familiar with from languages like Java.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">int</span> <span class="pl-en">plusOne</span>(<span class="pl-k">int</span> x) {
</span><span class="code-line highlight-line">  <span class="pl-k">return</span> x + <span class="pl-c1">1</span>;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">plusOne</span>(<span class="pl-k">double</span> x) {
</span><span class="code-line highlight-line">  <span class="pl-k">return</span> x + <span class="pl-c1">1</span>;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> x = plusOne(<span class="pl-c1">42</span>); <span class="pl-c">// calls plusOne&lt;int&gt;</span>
</span><span class="code-line"><span class="pl-k">auto</span> z = plusOne(<span class="pl-c1">2.71</span>);  <span class="pl-c">// calls plusOne&lt;double&gt;</span>
</span></code></pre>
<h5 id="generic-functions"><a href="#generic-functions">Generic Functions</a></h5>
<p>We can improve the code in the example above by making our function generic. This is easy to do in C++: we simply change the type of its input parameter to <code>auto</code>.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">plusOne</span>(<span class="pl-k">auto</span> x) {
</span><span class="code-line highlight-line">  <span class="pl-k">return</span> x + <span class="pl-c1">1</span>;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> a = plusOne(<span class="pl-c1">1230</span>); <span class="pl-c">// a == 1231, instantiates plusOne&lt;int&gt;</span>
</span><span class="code-line"><span class="pl-k">auto</span> b = plusOne(<span class="pl-c1">6</span>.<span class="pl-c1">5f</span>); <span class="pl-c">// b == 7.5f, instantiates plusOne&lt;float&gt;</span>
</span><span class="code-line"><span class="pl-k">auto</span> c = plusOne(<span class="pl-c1">3.14</span>); <span class="pl-c">// c == 4.14, instantiates plusOne&lt;double&gt;</span>
</span></code></pre>
<details><summary>Extra: what actually is an <code>auto</code> parameter?</summary><p>A function with at least one <code>auto</code> parameter, such as our generic <code>plusOne</code>, is known as an <strong><a href="https://en.cppreference.com/w/cpp/language/function_template#Abbreviated_function_template" target="_blank" rel="noopener noreferrer">abbreviated function template</a></strong>.</p></details>
<h5 id="extra-lambdas"><a href="#extra-lambdas">Extra: Lambdas</a></h5>
<p>There are also function-like entities in C++ called <em>lambdas</em>. We&#x27;ll not explain them in detail since functional programming is outside the scope of this lab. However, you are welcome to play with them and ask questions about them on Ed.</p>
<p>You may need to use lambdas for certain extra credit features, such as multithreading, in your future assignments. To get you started, a toy example is shown below.</p>
<details><summary>Example</summary><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">plus</span>(<span class="pl-k">auto</span> increment) {
</span><span class="code-line">  <span class="pl-k">return</span> [=](<span class="pl-k">auto</span> x) {
</span><span class="code-line">    <span class="pl-k">return</span> x + increment;
</span><span class="code-line">  };
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// Observe that functions are &quot;first-class&quot; in C++</span>
</span><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">apply</span>(<span class="pl-k">auto</span> operation, <span class="pl-k">auto</span> x) {
</span><span class="code-line">  <span class="pl-k">return</span> <span class="pl-c1">operation</span>(x);
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> x = apply(plus(<span class="pl-c1">20</span>), <span class="pl-c1">22</span>); <span class="pl-c">// x == 42</span>
</span><span class="code-line"><span class="pl-k">auto</span> y = apply(plus(-<span class="pl-c1">1.1</span>), <span class="pl-c1">4.24</span>); <span class="pl-c">// y == 3.14</span>
</span></code></pre></details>
<p>You can find more information about lambdas <a href="https://en.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener noreferrer">here</a>.</p>
<h4 id="a-warning-about-type-deduction"><a href="#a-warning-about-type-deduction">A Warning About Type Deduction</a></h4>
<div class="warning-callout callout"><p>Type deduction is very powerful in C++. For instance, most typed languages do not allow type deduction on function signatures like C++.
However, overusing it has a negative impact on the readability and maintainability of your code, and it can cause unexpected compilation errors/crashes.</p><p>Remember that C++ is a <a href="https://www.geeksforgeeks.org/what-is-a-typed-language/" target="_blank" rel="noopener noreferrer"><em>statically typed language</em></a>, meaning the type of a variable (e.g. int, float, etc.) <strong>cannot</strong> change after declaration; this applies to variables whose types are deduced using <code>auto</code>!</p></div>
<p>You should be very careful to strike a balance between type declaration and type deduction to maximize your code clarity. We recommend only using <code>auto</code> for <a href="#generic-functions">&quot;generic&quot; functions</a> and in cases when you are certain of the behavior of the deduced type.</p>
<p>Whenever possible, explicitly declare types in function signatures. Not doing so can lead to subtle, silent bugs which can be difficult to spot.</p>
<div class="task-callout callout"><p>We can now write functions and use them to process different things!</p><ol>
<li>Write a function <code>timesTwo</code> which takes an <code>int</code>, returns an <code>int</code>, and does what the function name suggests.</li>
<li>Add <code>std::cout &lt;&lt; timesTwo(21) &lt;&lt; std::endl;</code> to your <code>main</code> function.</li>
</ol><p>You should see <code>42</code> when you run the program.</p></div>
<div class="task-callout callout"><p>Let&#x27;s use what we learned and make <code>timesTwo</code> more interesting!</p><ol>
<li>Change the signature of <code>timesTwo</code> and make it generic.</li>
<li>You might also need to change the definition in the function body of <code>timesTwo</code> if you used multiplication for the previous task. Note that multiplication is not defined for <code>std::string</code>, but addition is, so how do you express &quot;times 2&quot; in the form of addition?</li>
<li>Add the following print statements to your <code>main</code> function:</li>
</ol><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line">std::cout &lt;&lt; timesTwo(<span class="pl-c1">123</span>) &lt;&lt; std::endl;
</span><span class="code-line">std::cout &lt;&lt; timesTwo(<span class="pl-c1">3.14</span>) &lt;&lt; std::endl;
</span><span class="code-line">std::cout &lt;&lt; timesTwo(std::string{ <span class="pl-s"><span class="pl-pds">&quot;</span>abc<span class="pl-pds">&quot;</span></span> }) &lt;&lt; std::endl;
</span></code></pre><p>You should see <code>246</code>, <code>6.28</code>, and <code>abcabc</code> when you run the program.</p></div>
<h3 id="structs-and-classes"><a href="#structs-and-classes">Structs and Classes</a></h3>
<p>Going beyond primitives, we can create custom types in C++ by combining existing types and bundling them with functions.</p>
<p>These custom types are known as <strong><em>structs/classes</em></strong>, and they can be defined using the <code>struct</code>/<code>class</code> keywords respectively.</p>
<p>Structs and classes are almost the same things in C++, with the only difference being that <code>struct</code>s have public member access by default and <code>class</code>es have private member access by default. The basic form of a <code>struct</code> is shown as follows:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">struct</span> <span class="pl-en">Rectangle</span> {
</span><span class="code-line">  <span class="pl-k">double</span> length;    <span class="pl-c">// A data member, also known as a field</span>
</span><span class="code-line">  <span class="pl-k">double</span> width = <span class="pl-c1">1</span>; <span class="pl-c">// Fields can have default values</span>
</span><span class="code-line">  <span class="pl-c">// Note: fields must be explicitly typed; you cannot use type deduction here</span>
</span><span class="code-line">
</span><span class="code-line">  <span class="pl-c">// A member function, also known as a method</span>
</span><span class="code-line">  <span class="pl-k">double</span> <span class="pl-en">calculateArea</span>() {
</span><span class="code-line">    <span class="pl-k">return</span> length * width;
</span><span class="code-line">  }
</span><span class="code-line">
</span><span class="code-line">  <span class="pl-c">// This member function modifies the struct instance&#x27;s state</span>
</span><span class="code-line">  <span class="pl-k">void</span> <span class="pl-en">makeItASquare</span>(<span class="pl-k">double</span> sideLength) {
</span><span class="code-line">    length = sideLength;
</span><span class="code-line">    width = sideLength;
</span><span class="code-line">  }
</span><span class="code-line">};
</span></code></pre>
<p>Here&#x27;s how we can create instances of <code>Rectangle</code>:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-c">// Create an instance of Rectangle</span>
</span><span class="code-line"><span class="pl-k">auto</span> x = Rectangle{ .<span class="pl-smi">length</span> = <span class="pl-c1">2</span>, .<span class="pl-smi">width</span> = <span class="pl-c1">4</span> };
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// Field names can be omitted. Values in the brackets will</span>
</span><span class="code-line"><span class="pl-c">// be assigned to each field sequentially</span>
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// Equivalent to Rectangle{ .length = 4, .width = 3 }</span>
</span><span class="code-line"><span class="pl-k">auto</span> y = Rectangle{ <span class="pl-c1">4</span>, <span class="pl-c1">3</span> };
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// Equivalent to Rectangle{ .length = 5, .width = 1 },</span>
</span><span class="code-line"><span class="pl-c">// because of the default value</span>
</span><span class="code-line"><span class="pl-k">auto</span> z = Rectangle{ <span class="pl-c1">5</span> };
</span></code></pre>
<p>And here&#x27;s how we can use those instances:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-c">// Remember that structs have public member access by default.</span>
</span><span class="code-line"><span class="pl-c">// If this Rectangle was a class, you&#x27;d have to declare the</span>
</span><span class="code-line"><span class="pl-c">// relevant fields/methods public to do this</span>
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// Getting and setting fields</span>
</span><span class="code-line"><span class="pl-k">auto</span> oldLength = x.length;        <span class="pl-c">// oldLength == 2</span>
</span><span class="code-line">x.length = <span class="pl-c1">4</span>;
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// Calling member functions</span>
</span><span class="code-line"><span class="pl-k">auto</span> newArea = x.calculateArea(); <span class="pl-c">// newArea == 16</span>
</span><span class="code-line">x.makeItASquare(oldLength);       <span class="pl-c">// x.length == x.width == 2</span>
</span></code></pre>
<details><summary>A warning about constructors and other special member functions</summary><p>If you have any experience in class-based OOP, you probably know that you can use <strong>constructors</strong> to initialize an object, instead of initializing it field-by-field (aggregate initialization).</p><p>However, we generally recommend that you <em>do not</em> manually define your own constructors.</p><p>Instead, we suggest using <strong><a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization" target="_blank" rel="noopener noreferrer">aggregate types</a></strong> where possible.</p><p>Improper handling of constructors and other special member functions* can break <em><a href="https://isocpp.org/wiki/faq/value-vs-ref-semantics" target="_blank" rel="noopener noreferrer">value semantics</a></em> for your type, and cause unexpected bugs or resource leaks.</p><p>And, while it is entirely possible that you may never encounter or notice such a bug even if you do use special member functions, we still recommend using aggregate types as the less error-prone option.</p><p>* special member functions = default constructors, copy constructors, move constructors, copy assignment operators, move assignment operators, and destructors</p></details>
<div class="task-callout callout"><p>Let&#x27;s add more behaviors to our <code>Rectangle</code> type and enhance its capabilities!</p><ol>
<li>Add a method <code>calculatePerimeter</code> to <code>Rectangle</code>.</li>
<li>Add <code>std::cout &lt;&lt; Rectangle{ 7, 8 }.calculatePerimeter() &lt;&lt; std::endl;</code> to your <code>main</code> function.</li>
</ol><p>You should see <code>30</code> when you run the program.</p></div>
<div class="task-callout callout"><p>Now that we&#x27;ve seen what we can do with <code>Rectangle</code>, are you ready to create a new type from ground zero?</p><ol>
<li>Create a <code>Circle</code> type using the <code>struct</code> keyword.</li>
<li><code>Circle</code> should contain a field <code>radius</code> of type <code>float</code>, and two methods <code>calculateArea</code> and <code>calculatePerimeter</code>.</li>
<li>Tip: to use <span class="math math-inline"><mjx-container className="MathJax" jax="SVG"><svg style="vertical-align:-0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.29ex" height="1ex" role="img" focusable="false" viewBox="0 -431 570 442" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D70B" d="M132 -11Q98 -11 98 22V33L111 61Q186 219 220 334L228 358H196Q158 358 142 355T103 336Q92 329 81 318T62 297T53 285Q51 284 38 284Q19 284 19 294Q19 300 38 329T93 391T164 429Q171 431 389 431Q549 431 553 430Q573 423 573 402Q573 371 541 360Q535 358 472 358H408L405 341Q393 269 393 222Q393 170 402 129T421 65T431 37Q431 20 417 5T381 -10Q370 -10 363 -7T347 17T331 77Q330 86 330 121Q330 170 339 226T357 318T367 358H269L268 354Q268 351 249 275T206 114T175 17Q164 -11 132 -11Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D70B" xlink:href="#MJX-1-TEX-I-1D70B"></use></g></g></g></svg></mjx-container></span>, you can use <code>std::numbers::pi</code>.</li>
<li>After completing your <code>Circle</code> type, create a few instances of <code>Circle</code> in your <code>main</code> function, and call some of their methods.</li>
</ol><p>See if your <code>Circle</code> instances exhibit the expected behaviors when you run the program.</p></div>
<p>Now, we have 2 types <code>Rectangle</code> and <code>Circle</code>, with the same member functions <code>calculateArea</code> and <code>calculatePerimeter</code>. Can we define one <code>printShape</code> function that works for both types?</p>
<h4 id="generic-functions-reprise"><a href="#generic-functions-reprise">Generic Functions (Reprise)</a></h4>
<p>If you have previous experience in OOP, you might think of defining a <code>Shape</code> interface with a <code>printShape()</code> abstract function, and have both <code>Rectangle</code> and <code>Circle</code> both implement <code>Shape</code>. This is unnecessary in C++.</p>
<p>Remember the generic functions we learned in the previous section? If a function has a parameter of <code>auto</code> type, it is allowed to be anything! We can pass <code>Rectangle</code> and <code>Circle</code> instances to it just like that!</p>
<details><summary>Extra: more on templates, for those familiar with programming languages</summary><p>The reason behind this magic is that C++ templates are <a href="https://en.wikipedia.org/wiki/Structural_type_system" target="_blank" rel="noopener noreferrer">structurally typed</a>, and they do not enforce <a href="https://en.wikipedia.org/wiki/Parametricity" target="_blank" rel="noopener noreferrer">parametricity</a>. The lack of parametricity means when a type parameter gets reified by an actual type <code>T</code>, the type information of <code>T</code> is <strong>not</strong> erased in the body of the function template. This allows template definition to rely on any ad-hoc property of <code>T</code>, including inspecting what <code>T</code> actually is. Such capability enables templates to simulate features commonly seen in a dependently-typed system, or an untyped language.</p><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-c">// a function template that only accepts containers with no more than 42 elements</span>
</span><span class="code-line"><span class="pl-c">// simulating a dependently typed function</span>
</span><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">f</span>(<span class="pl-k">auto</span> x) requires (x.size() &lt;= 42) {
</span><span class="code-line">    <span class="pl-c">// empty</span>
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-en">f</span>(std::array&lt;<span class="pl-k">int</span>, <span class="pl-c1">10</span>&gt;{}); <span class="pl-c">// OK</span>
</span><span class="code-line"><span class="pl-c">// f(std::array&lt;int, 43&gt;{}); &lt;- error</span>
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// a function template whose return type depends on its input</span>
</span><span class="code-line"><span class="pl-c">// simulating an untyped function</span>
</span><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">g</span>(<span class="pl-k">auto</span> x) {
</span><span class="code-line">    <span class="pl-c">// if the input can be invoked like a function</span>
</span><span class="code-line">    <span class="pl-c">// the return type is the same as the input&#x27;s return type</span>
</span><span class="code-line">    <span class="pl-k">if</span> <span class="pl-k">constexpr</span> (requires { <span class="pl-c1">x</span>(); })
</span><span class="code-line">        <span class="pl-k">return</span> <span class="pl-c1">x</span>();
</span><span class="code-line">    <span class="pl-c">// otherwise return type is int</span>
</span><span class="code-line">    <span class="pl-k">else</span>
</span><span class="code-line">        <span class="pl-k">return</span> <span class="pl-c1">42</span>;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> x = g([] { <span class="pl-k">return</span> <span class="pl-c1">2.71</span>; }); <span class="pl-c">// x is of type double</span>
</span><span class="code-line"><span class="pl-k">auto</span> y = g(<span class="pl-s"><span class="pl-pds">&quot;</span>aaa<span class="pl-pds">&quot;</span></span>); <span class="pl-c">// y is of type int</span>
</span></code></pre></details>
<div class="task-callout callout"><p>Navigate to the empty function <code>printShape</code>.</p><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">void</span> <span class="pl-en">printShape</span>(<span class="pl-k">auto</span> shape) {
</span><span class="code-line">  <span class="pl-c">// Your code here</span>
</span><span class="code-line">}
</span></code></pre><p>Complete its definition, so that when you pass in either a <code>Rectangle</code> object or a <code>Circle</code> object, it prints:</p><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line">Area: <span class="pl-c">/* area of the shape */</span>
</span><span class="code-line">Perimeter: <span class="pl-c">/* perimeter of the shape */</span>
</span></code></pre><p>Call <code>printShape</code> in <code>main()</code> with different <code>Rectangle</code> and <code>Circle</code> instances, to see if <code>printShape</code> exhibits the expected polymorphic behavior.</p></div>
<h3 id="other-standard-library-utilities"><a href="#other-standard-library-utilities">Other Standard Library Utilities</a></h3>
<p>Besides iostream, the C++ standard library provides us with many useful utilities, and we&#x27;ll focus on the four most commonly used ones: its containers and strings.</p>
<h4 id="arrays"><a href="#arrays">Arrays</a></h4>
<p><a href="https://en.cppreference.com/w/cpp/container/array" target="_blank" rel="noopener noreferrer"><code>std::array</code></a> is a fixed-length array.</p>
<details><summary>Example</summary><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number highlight-line" line="1">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>array<span class="pl-pds">&gt;</span></span>
</span><span class="code-line line-number" line="2">
</span><span class="code-line line-number" line="3"><span class="pl-k">auto</span> x = std::array&lt;<span class="pl-k">int</span>, <span class="pl-c1">3</span>&gt;{}; <span class="pl-c">// Must declare element type and length</span>
</span><span class="code-line line-number" line="4">
</span><span class="code-line line-number" line="5"><span class="pl-c">// Element type and length can be deduced if you immediately initialize</span>
</span><span class="code-line line-number" line="6"><span class="pl-c">// the array with values</span>
</span><span class="code-line line-number" line="7"><span class="pl-k">auto</span> y = std::array{ <span class="pl-c1">3</span>.<span class="pl-c1">14f</span>, <span class="pl-c1">2</span>.<span class="pl-c1">71f</span> };
</span><span class="code-line line-number" line="8">
</span><span class="code-line line-number" line="9"><span class="pl-c">// Getting and setting array elements</span>
</span><span class="code-line line-number" line="10"><span class="pl-k">auto</span> z = y[<span class="pl-c1">0</span>]; <span class="pl-c">// z == 3.14f</span>
</span><span class="code-line line-number" line="11">x[<span class="pl-c1">0</span>] = <span class="pl-c1">42</span>; <span class="pl-c">// now, the zeroth element of x is 42</span>
</span><span class="code-line line-number" line="12">
</span><span class="code-line line-number" line="13"><span class="pl-k">auto</span> [a, b, c] = x; <span class="pl-c">// Arrays can be unpacked: a == 42, b == 0, c == 0</span>
</span><span class="code-line line-number" line="14">
</span><span class="code-line line-number" line="15"><span class="pl-c">// Commonly used array methods</span>
</span><span class="code-line line-number" line="16"><span class="pl-k">auto</span> lengthX = x.size();
</span><span class="code-line line-number" line="17"><span class="pl-k">auto</span> underlyingPointer = x.data(); <span class="pl-c">// we&#x27;ll explain pointers later</span>
</span><span class="code-line line-number" line="18">
</span><span class="code-line line-number" line="19"><span class="pl-c">// Arrays can be looped over element-wise</span>
</span><span class="code-line line-number" line="20"><span class="pl-k">for</span> (<span class="pl-k">auto</span> element : y) {
</span><span class="code-line line-number" line="21">  std::cout &lt;&lt; element &lt;&lt; std::endl; <span class="pl-c">// prints 3.14, then 2.71</span>
</span><span class="code-line line-number" line="22">}
</span></code></pre></details>
<h4 id="vectors"><a href="#vectors">Vectors</a></h4>
<p><a href="https://en.cppreference.com/w/cpp/container/vector" target="_blank" rel="noopener noreferrer"><code>std::vector</code></a> is a dynamic-length array. Unlike <code>std::array</code>, it allows us to insert or remove elements at any time, and it has mostly the same capabilities as <code>std::array</code>. However, <code>std::array</code> is slightly more performant as it doesn&#x27;t require dynamic memory allocation.</p>
<details><summary>Example</summary><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number highlight-line" line="1">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>vector<span class="pl-pds">&gt;</span></span>
</span><span class="code-line line-number" line="2">
</span><span class="code-line line-number" line="3"><span class="pl-k">auto</span> x = std::vector&lt;<span class="pl-k">int</span>&gt;{}; <span class="pl-c">// Must declare element type</span>
</span><span class="code-line line-number" line="4">
</span><span class="code-line line-number" line="5"><span class="pl-c">// Element type can be deduced if you immediately initialize</span>
</span><span class="code-line line-number" line="6"><span class="pl-c">// the vector with values</span>
</span><span class="code-line line-number" line="7"><span class="pl-k">auto</span> y = std::vector{ <span class="pl-c1">3</span>.<span class="pl-c1">14f</span>, <span class="pl-c1">2</span>.<span class="pl-c1">71f</span> };
</span><span class="code-line line-number" line="8">
</span><span class="code-line line-number" line="9"><span class="pl-c">// Manipulating vector elements</span>
</span><span class="code-line line-number" line="10"><span class="pl-k">auto</span> z = y[<span class="pl-c1">0</span>]; <span class="pl-c">// z == 3.14f</span>
</span><span class="code-line line-number" line="11">x.push_back(<span class="pl-c1">42</span>); <span class="pl-c">// add an element to the end of the vector</span>
</span><span class="code-line line-number" line="12">x.push_back(<span class="pl-c1">123</span>); <span class="pl-c">// add another element after the 42 we just inserted</span>
</span><span class="code-line line-number" line="13">x.pop_back(); <span class="pl-c">// remove the element we just added</span>
</span><span class="code-line line-number" line="14">
</span><span class="code-line line-number" line="15"><span class="pl-c">// Commonly used vector methods</span>
</span><span class="code-line line-number" line="16"><span class="pl-k">auto</span> lengthX = x.size();
</span><span class="code-line line-number" line="17">y.reserve(<span class="pl-c1">20</span>); <span class="pl-c">// Pre-allocate memory for more elements. Its length stays the same</span>
</span><span class="code-line line-number" line="18">x.resize(<span class="pl-c1">10</span>); <span class="pl-c">// Resize the vector, actually changing its number of elements (length)</span>
</span><span class="code-line line-number" line="19"><span class="pl-k">auto</span> underlyingPointer = x.data(); <span class="pl-c">// we&#x27;ll explain pointers later</span>
</span><span class="code-line line-number" line="20">
</span><span class="code-line line-number" line="21"><span class="pl-c">// Vectors can be looped over element-wise</span>
</span><span class="code-line line-number" line="22"><span class="pl-k">for</span> (<span class="pl-k">auto</span> element : y) {
</span><span class="code-line line-number" line="23">  std::cout &lt;&lt; element &lt;&lt; <span class="pl-s"><span class="pl-pds">&quot;</span> <span class="pl-pds">&quot;</span></span>; <span class="pl-c">// prints 3.14, then 2.71</span>
</span><span class="code-line line-number" line="24">}
</span></code></pre></details>
<h4 id="tuples"><a href="#tuples">Tuples</a></h4>
<p><a href="https://en.cppreference.com/w/cpp/utility/tuple" target="_blank" rel="noopener noreferrer"><code>std::tuple</code></a> is a heterogeneous containerâ€”it is capable of storing elements of <em>different</em> types. It is most commonly used to achieve <strong>multiple return values</strong> in C++.</p>
<details><summary>Example</summary><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number highlight-line" line="1">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>tuple<span class="pl-pds">&gt;</span></span>
</span><span class="code-line line-number" line="2">
</span><span class="code-line line-number" line="3"><span class="pl-k">auto</span> <span class="pl-en">makeTuple</span>(<span class="pl-k">auto</span> x, <span class="pl-k">auto</span> y) {
</span><span class="code-line line-number" line="4">  <span class="pl-k">return</span> std::tuple{ x, y };
</span><span class="code-line line-number" line="5">}
</span><span class="code-line line-number" line="6">
</span><span class="code-line line-number" line="7"><span class="pl-k">auto</span> [x, y] = makeTuple(<span class="pl-c1">42</span>, <span class="pl-c1">3.14</span>); <span class="pl-c">// tuples can be unpacked, x == 42, y == 3.14</span>
</span><span class="code-line line-number" line="8">
</span><span class="code-line line-number" line="9"><span class="pl-c">// This is a variadic function template: it takes any number of arguments, each of any type</span>
</span><span class="code-line line-number" line="10"><span class="pl-c">// It is unlikely that you&#x27;ll need to use variadic functions for this course</span>
</span><span class="code-line line-number" line="11"><span class="pl-k">auto</span> <span class="pl-en">doubleEach</span>(<span class="pl-k">auto</span> ...x) {
</span><span class="code-line line-number" line="12">  <span class="pl-k">return</span> std::tuple{ x + x... };
</span><span class="code-line line-number" line="13">}
</span><span class="code-line line-number" line="14">
</span><span class="code-line line-number" line="15"><span class="pl-k">auto</span> [a, b, c] = doubleEach(<span class="pl-c1">12</span>, <span class="pl-c1">2.71</span>, std::string{ <span class="pl-s"><span class="pl-pds">&quot;</span>abc<span class="pl-pds">&quot;</span></span> });
</span><span class="code-line line-number" line="16"><span class="pl-c">// a == 24, b == 5.42, c == &quot;abcabc&quot;</span>
</span></code></pre></details>
<h4 id="strings"><a href="#strings">Strings</a></h4>
<p><code>std::string</code> provides basic string operations in C++. You can find its documentation <a href="https://en.cppreference.com/w/cpp/string/basic_string" target="_blank" rel="noopener noreferrer">here</a>.</p>
<details><summary>Example</summary><p>The example below shows you how to create string objects, or convert string literals to <code>std::string</code></p><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number highlight-line" line="1">#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>string<span class="pl-pds">&gt;</span></span>
</span><span class="code-line line-number" line="2">
</span><span class="code-line line-number" line="3"><span class="pl-k">auto</span> x = std::string{}; <span class="pl-c">// Create an empty string</span>
</span><span class="code-line line-number" line="4"><span class="pl-k">auto</span> y = std::string{ <span class="pl-s"><span class="pl-pds">&quot;</span>hello!<span class="pl-pds">&quot;</span></span> }; <span class="pl-c">// Convert a string literal to a std::string</span>
</span><span class="code-line line-number" line="5">
</span><span class="code-line line-number" line="6"><span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span>::literals<span class="pl-k">;</span> <span class="pl-c">// Use this namespace to create std::string literals</span>
</span><span class="code-line line-number" line="7"><span class="pl-k">auto</span> z = <span class="pl-s"><span class="pl-pds">&quot;</span>abcd<span class="pl-pds">&quot;</span></span>s;              <span class="pl-c">// Create a std::string literal, note the s suffix</span>
</span><span class="code-line line-number" line="8">z += <span class="pl-s"><span class="pl-pds">&quot;</span>efgh<span class="pl-pds">&quot;</span></span>;                   <span class="pl-c">// Use + to concatenate strings</span>
</span></code></pre></details>
<h4 id="iterating-over-containers"><a href="#iterating-over-containers">Iterating Over Containers</a></h4>
<p>Defining containers is one thing, but we also need to know how to operate over the elements. There are two primary methods for iterating: the range-for loop, and index-based iteration.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-c">// range-for</span>
</span><span class="code-line"><span class="pl-k">for</span> (<span class="pl-k">auto</span> element : container) {
</span><span class="code-line">  <span class="pl-c">// use element</span>
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// index-based</span>
</span><span class="code-line"><span class="pl-k">for</span> (<span class="pl-k">auto</span> index = <span class="pl-c1">0</span>; index &lt; container.size(); ++index) {
</span><span class="code-line">  <span class="pl-k">auto</span> element = container[index];
</span><span class="code-line">  <span class="pl-c">// use element</span>
</span><span class="code-line">}
</span></code></pre>
<p>Note that a more efficient way of doing the range-for loop is to use an ampersand after <code>auto</code>. You will learn more about what this means in the section on references.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-c">// reference based range-for</span>
</span><span class="code-line"><span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp; element : container) {
</span><span class="code-line">  <span class="pl-c">// use element by reference</span>
</span><span class="code-line">}
</span></code></pre>
<div class="task-callout callout"><p>Now that we&#x27;ve learned the basics of containers and strings, let&#x27;s try using them!</p><ol>
<li>Create an array of <code>std::strings</code>. You&#x27;re free to pick either <code>std::array</code> or <code>std::vector</code>.</li>
<li>Fill the container with some strings.</li>
<li>Apply <code>timesTwo</code> to each string element in the container. Hint: you cannot use the range-for loop you saw above to modify container elements, you&#x27;ll see why in the following section when we explain references.</li>
<li>Print each string element in the container, and see if the result is what you expect.</li>
</ol></div>
<h3 id="pointers-and-references"><a href="#pointers-and-references">Pointers and References</a></h3>
<p>Every entity in our program, from variables to functions to constants etc, all exist somewhere in memory, and they all have a unique memory location called a <em>memory</em> <em>address</em>.</p>
<p>A <em>pointer</em> is an integer storing a memory address, and it allows us to manipulate the object at that address. We can obtain a pointer to almost anything in C++ by taking its address using the <em>address</em> <em>of</em> operator <code>&amp;</code>. The obtained address will be of a pointer type, denoted by the target object type followed by an asterisk <code>*</code>.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">int</span> x = <span class="pl-c1">42</span>;
</span><span class="code-line"><span class="pl-k">int</span>* px = &amp;x; <span class="pl-c">// px is a pointer to an integer, pointing to x</span>
</span><span class="code-line"><span class="pl-k">auto</span> px2 = &amp;x; <span class="pl-c">// type deduction works for pointers too, type of px2 deduced to int*</span>
</span><span class="code-line"><span class="pl-k">auto</span>* px3 = &amp;x; <span class="pl-c">// partial type deduction works too, px3 is a pointer to some deduced type, auto deduced to int</span>
</span><span class="code-line"><span class="pl-c">// pointer variables themselves also reside somewhere in memory, you can get a pointer to pointer</span>
</span><span class="code-line"><span class="pl-k">auto</span> ppx = &amp;px; <span class="pl-c">// ppx is of type int**, a pointer to a pointer to an integer</span>
</span><span class="code-line"><span class="pl-c">// let&#x27;s see where x is located in (virtual) memory!</span>
</span><span class="code-line"><span class="pl-k">auto</span> MemoryAddressOfX = <span class="pl-k">reinterpret_cast</span>&lt;<span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span>&gt;(px); <span class="pl-c">// cast pointer to largest integer type</span>
</span><span class="code-line">std::cout &lt;&lt; MemoryAddressOfX;
</span></code></pre>
<p>The first thing we can do with a pointer is to access the entity at the address that the pointer points to. This can be achieved by using the <em>dereference</em> operator which also has the form of a star <code>*</code>. For pointers to non-primitive types, we can also use <code>-&gt;</code> to access its members.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> x = <span class="pl-c1">42</span>;
</span><span class="code-line"><span class="pl-k">auto</span> y = Rectangle{ .<span class="pl-smi">length</span> = <span class="pl-c1">4</span>, .<span class="pl-smi">width</span> = <span class="pl-c1">2</span> };
</span><span class="code-line"><span class="pl-k">auto</span> px = &amp;x;
</span><span class="code-line"><span class="pl-k">auto</span>* py = &amp;y; <span class="pl-c">// you could still write out * along with auto to make it extra clear that it is a pointer.</span>
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// This is how we access the object that a pointer points to</span>
</span><span class="code-line"><span class="pl-k">auto</span> x2 = *px; <span class="pl-c">// x2 == x == 42</span>
</span><span class="code-line"><span class="pl-k">auto</span> y2 = *py; <span class="pl-c">// y2 == y == Rectangle{ .length = 4, .width = 2 }</span>
</span><span class="code-line"><span class="pl-k">auto</span> a = py-&gt;<span class="pl-en">calculateArea</span>(); <span class="pl-c">// same as y.calculateArea()</span>
</span><span class="code-line"><span class="pl-k">auto</span> yLength = py-&gt;length; <span class="pl-c">// same as y.length</span>
</span></code></pre>
<p>Dereferencing a pointer also allows us to modify the object that it points to</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> x = <span class="pl-c1">42</span>;
</span><span class="code-line"><span class="pl-k">auto</span> y = Rectangle{ .<span class="pl-smi">length</span> = <span class="pl-c1">4</span>, .<span class="pl-smi">width</span> = <span class="pl-c1">2</span> };
</span><span class="code-line"><span class="pl-k">auto</span> px = &amp;x;
</span><span class="code-line"><span class="pl-k">auto</span> py = &amp;y;
</span><span class="code-line">
</span><span class="code-line">*px = <span class="pl-c1">123</span>; <span class="pl-c">// this sets x to 123</span>
</span><span class="code-line">py-&gt;width = <span class="pl-c1">3</span>; <span class="pl-c">// this sets y.width to 3</span>
</span><span class="code-line">
</span><span class="code-line">std::cout &lt;&lt; x; <span class="pl-c">// you should see 123 here</span>
</span><span class="code-line">std::cout &lt;&lt; y.width; <span class="pl-c">// you should see 3 here</span>
</span></code></pre>
<div class="task-callout callout"><p>Let&#x27;s see what we can do with pointers!</p><p>Navigate to the empty function <code>inplaceTimesTwo</code>. It has the same functionality as our previous generic <code>timesTwo</code>, however, it modifies the input variable in place rather than returning a new value.</p><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">void</span> <span class="pl-en">inplaceTimesTwo</span>(<span class="pl-c">/* ??? pointerToSomeVariable */</span>) {
</span><span class="code-line">    <span class="pl-c">// your code here</span>
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> x = <span class="pl-c1">21</span>;
</span><span class="code-line"><span class="pl-k">auto</span> y = std::string{ <span class="pl-s"><span class="pl-pds">&quot;</span>abcd<span class="pl-pds">&quot;</span></span> };
</span><span class="code-line">
</span><span class="code-line"><span class="pl-en">inplaceTimesTwo</span>(&amp;x);
</span><span class="code-line"><span class="pl-en">inplaceTimesTwo</span>(&amp;y);
</span><span class="code-line">
</span><span class="code-line">std::cout &lt;&lt; x; <span class="pl-c">// you should see 42 here</span>
</span><span class="code-line">std::cout &lt;&lt; y; <span class="pl-c">// you should see &quot;abcdabcd&quot; here</span>
</span></code></pre><ul>
<li>Uncomment the <code>pointerToSomeVariable</code> parameter, replace <code>???</code> with a proper type declaration. (hint: both <code>auto</code> and <code>auto*</code> can represent a pointer of any type).</li>
<li>Complete the function body using what we learned.</li>
<li>Uncomment the supporting code in <code>main()</code> for task 9, execute the program and see if you get the expected result.</li>
</ul></div>
<p>You might&#x27;ve noticed that pointers are somewhat unwieldy to use; we have to first take the address of something, then dereference the pointer. This can be simplified by the use of <em>references</em>. A reference is essentially a dereferenced pointer, meaning the entity at a particular memory address. You can find more information about the connection between pointers and references <a href="/website-fall-23/docs/advanced-cpp-tutorial#pointers-and-references-reprise">here</a>. The reference type is denoted by the entity type followed by <code>&amp;</code>.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">int</span> x = <span class="pl-c1">42</span>;
</span><span class="code-line"><span class="pl-k">int</span>&amp; refx = x; <span class="pl-c">// a reference to x, it has the same memory address as x</span>
</span><span class="code-line"><span class="pl-k">auto</span>&amp; refx2 = x; <span class="pl-c">// we may use type deduction with references, type of refx2 deduced to int&amp;</span>
</span><span class="code-line">
</span><span class="code-line">refx = <span class="pl-c1">123</span>; <span class="pl-c">// this sets x to 123 because refx and x share the same memory address</span>
</span><span class="code-line">std::cout &lt;&lt; x; <span class="pl-c">// you should see 123 here</span>
</span></code></pre>
<p>One thing we have to be careful about with references is that we <strong>always</strong> have to spell out <code>&amp;</code> in the type declaration when creating a reference, whether we&#x27;re using type deduction or not. Otherwise, we&#x27;d be creating a copy rather than a reference.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">int</span> x = <span class="pl-c1">42</span>;
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">int</span>&amp; refx = x; <span class="pl-c">// a reference to x, same memory address as x</span>
</span><span class="code-line"><span class="pl-k">auto</span>&amp; refx2 = x; <span class="pl-c">// a reference to x, same memory address as x</span>
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">int</span> y = x; <span class="pl-c">// this is a copy of x! it&#x27;s a new variable with its own unique address!</span>
</span><span class="code-line"><span class="pl-k">auto</span> y2 = x; <span class="pl-c">// again, it&#x27;s a copy with its own unique address!</span>
</span></code></pre>
<p>This is because C++ has <em>value semantics</em> by default.</p>
<details><summary>Extra: To be precise...</summary><p>This is known as lvalue-to-rvalue <a href="https://en.cppreference.com/w/cpp/language/implicit_conversion#Lvalue_to_rvalue_conversion">type decay</a> in C++ terminology.</p></details>
<p>Now that we know C++ makes a copy when creating something from another unless specified otherwise (i.e. creating
a reference). We should really change most of the parameter types in our function signature to references unless
it&#x27;s something trivial like an <code>int</code> or <code>double</code>. Otherwise, a full copy will be made for every object we passed
to the function, and it could lead to serious performance problems!</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">void</span> <span class="pl-en">func</span>(std::vector&lt;<span class="pl-k">int</span>&gt; things) {
</span><span class="code-line">    <span class="pl-c">// empty</span>
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">void</span> <span class="pl-en">betterFunc</span>(std::vector&lt;<span class="pl-k">int</span>&gt;&amp; things) {
</span><span class="code-line">    <span class="pl-c">// empty</span>
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> things = std::vector{ <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span> };
</span><span class="code-line">
</span><span class="code-line"><span class="pl-en">func</span>(things); <span class="pl-c">// &#x27;things&#x27; will be shallow-copied when you call func(), because it gets passed by value!</span>
</span><span class="code-line">
</span><span class="code-line"><span class="pl-en">betterFunc</span>(things); <span class="pl-c">// no copy will be made here! because &#x27;things&#x27; gets passed by reference!</span>
</span><span class="code-line"><span class="pl-c">// This also means if betterFunc modifies &#x27;things&#x27; in any way in its function body, it will be reflected here</span>
</span></code></pre>
<p>The same also applies to looping over containers. You need to use <strong>references</strong> in a range-for loop to modify elements.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> things = std::vector{ <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span> };
</span><span class="code-line"><span class="pl-c">// this copies every element in &#x27;things&#x27;</span>
</span><span class="code-line"><span class="pl-c">// not ideal if the element type is not trivial to copy</span>
</span><span class="code-line"><span class="pl-k">for</span> (<span class="pl-k">auto</span> x : things) {
</span><span class="code-line">    std::cout &lt;&lt; x &lt;&lt; std::endl;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">for</span> (<span class="pl-k">auto</span>&amp; x : things) { <span class="pl-c">// this loops over each element by reference</span>
</span><span class="code-line">    x += x;              <span class="pl-c">// which also enables you to modify the elements</span>
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// now things = [2, 4, 6, 8]</span>
</span></code></pre>
<div class="task-callout callout"><p>Let&#x27;s try our hand at references!</p><ol>
<li>Navigate to the empty function <code>doubleEachElement</code>, this function takes any container and doubles each element in the container.</li>
</ol><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">void</span> <span class="pl-en">doubleEachElement</span>(<span class="pl-c">/* ??? container */</span>) {
</span><span class="code-line">    <span class="pl-c">// your code here</span>
</span><span class="code-line">}
</span></code></pre><ol start="2">
<li>Uncomment the <code>container</code> parameter, and replace <code>???</code> with a proper type declaration. (hint: references work with generic parameters too!).</li>
<li>Complete the function body using what we learned.</li>
<li>Pass different <code>std::array</code> and <code>std::vector</code> objects to <code>doubleEachElement</code> in your <code>main</code> function.</li>
</ol><p>Print the results after <code>doubleEachElement</code> calls, and see if it matches your expectation!</p></div>
<h2 id="debugging"><a href="#debugging">Debugging</a></h2>
<p>The programs you&#x27;ll write in this class will often crash or exhibit weird behavior due to bugs.
Debugging is a vital skill, and learning to efficiently debug will go a long way.
While printing out variable values to the terminal is a valid debugging method, it can quickly introduce clutter and make it difficult to diagnose deeper issues.</p>
<p>We strongly recommend using QtCreator&#x27;s built-in debugger.
Like most other debuggers, it allows you to interactively pause program execution at breakpoints, step through your programs line by line, and inspect variable values at every point.</p>
<div class="task-callout callout"><p>Let&#x27;s use the QtCreator debugger to fix a problematic function.</p><ol>
<li>Change your build configuration from <code>Release</code> to <code>Debug</code>.</li>
</ol><figure id="figure-4" class="image-wrapper"><div class="image-grid" style="--target-width:35%"><a href="/website-fall-23/labs/lab1/debug_kit.jpg" target="_blank" rel="noopener noreferrer"><img src="/labs/lab1/debug_kit.jpg" alt="QtCreator Debug Mode"/></a></div><figcaption><strong>Figure 4: </strong>QtCreator Debug Build</figcaption></figure><p>We&#x27;ve provided you with a buggy function called <code>generateSequence</code> which is supposed to output the sequence <code>(1, 1/2, 1/3, ..., 1/n)</code> contained in a vector.</p><ol start="2">
<li>In <code>main()</code>, uncomment the calls to <code>generateSequence()</code> and <code>verifySequence()</code>.</li>
</ol><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">void</span> <span class="pl-en">main</span>() {
</span><span class="code-line">  <span class="pl-c">// ...</span>
</span><span class="code-line">  <span class="pl-c">// code for previous tasks</span>
</span><span class="code-line">
</span><span class="code-line">
</span><span class="code-line">  <span class="pl-c">// Task 11:</span>
</span><span class="code-line">  std::vector&lt;<span class="pl-k">float</span>&gt; sequence = <span class="pl-c1">generateSequence</span>(<span class="pl-c1">5</span>);
</span><span class="code-line">  <span class="pl-c1">verifySequence</span>(sequence);
</span><span class="code-line">}
</span></code></pre><ol start="3">
<li>Run the program. You should see an error message in your terminal :(</li>
</ol></div>
<p>Let&#x27;s see how we can use the debugger to figure out what&#x27;s wrong with <code>generateSequence</code>.</p>
<div class="task-callout callout"><ol>
<li>Set a breakpoint at the start of the <code>generateSequence</code> function by clicking the region to the left of your chosen line number.</li>
</ol><ul>
<li>A red circle should appear indicating that the program will pause execution at that line when run in debug mode.</li>
</ul><ol start="2">
<li>Run the program in debug mode by pressing the button above Build:</li>
</ol><figure id="figure-5" class="image-wrapper"><div class="image-grid" style="--target-width:35%"><a href="/website-fall-23/labs/lab1/debug_icon.jpg" target="_blank" rel="noopener noreferrer"><img src="/labs/lab1/debug_icon.jpg" alt="Button to start debugging session"/></a></div><figcaption><strong>Figure 5: </strong>Button to start debugging session</figcaption></figure></div>
<p>The program should run up to and pause at your breakpoint. You should see something similar to the following:</p>
<figure id="figure-6" class="image-wrapper"><div class="image-grid" style="--target-width:95%"><a href="/website-fall-23/labs/lab1/debugger_panels.jpg" target="_blank" rel="noopener noreferrer"><img src="/labs/lab1/debugger_panels.jpg" alt="QtCreator Debug Mode"/></a></div><figcaption><strong>Figure 6: </strong>QtCreator Debugger Panels.</figcaption></figure>
<p>The debugger will display several panels. The ones you&#x27;ll most often interact with (highlighted in Figure 6) are the:</p>
<ul>
<li><strong>Locals</strong>: this is a list of the variables accessible in your current scope. You can examine their types and <em>current</em> values. Note that some may not be initialized yet and will have arbitrary values!</li>
<li><strong>Execution control buttons</strong>: these buttons allow you to resume/pause/stop the program and execute individual lines of code.</li>
<li><strong>Call stack</strong>: this shows you where you currently are in the execution of the program. In this case, you are in <code>generateSequence</code>, which was called from <code>main</code>.</li>
</ul>
<div class="task-callout callout"><p>Execute each line of <code>generateSequence</code> one at a time by repeatedly pressing the &quot;step over&quot; button.</p><figure id="figure-7" class="image-wrapper"><div class="image-grid" style="--target-width:75%"><a href="/website-fall-23/labs/lab1/debugger_execution.jpg" target="_blank" rel="noopener noreferrer"><img src="/labs/lab1/debugger_execution.jpg" alt="QtCreator Debug Mode"/></a></div><figcaption><strong>Figure 7: </strong>Step Over button in the execution control panel</figcaption></figure><ul>
<li>Pay attention to how the variable values in the locals panel update after each line is executed - You can view
the elements inside a container (e.g. <code>std::vector</code>) by clicking on the triangle next to their variable name in
the locals panel once the variable has been initialized.</li>
</ul></div>
<div class="task-callout callout"><ol>
<li>
<p>Find and correct the bug! You only need to edit the code in <code>generateSequence</code>.</p>
<ul>
<li>Remember that the desired output sequence is <code>(1, 1/2, 1/3, ..., 1/n)</code></li>
<li>You can always restart the debugger by pressing the green power icon in the execution control panel.</li>
</ul>
</li>
<li>
<p>Verify that you&#x27;ve fixed the bug by letting the program finish executing. <strong>You should no longer see the error message</strong>.</p>
</li>
</ol><details><summary><em>Hint</em></summary><p>Pay special attention to the <code>temp</code> variable. It will be helpful to use the debugger to inspect its properties.</p></details></div>
<p>It may have been possible to spot the bug simply by inspection in this task, but this is seldom the case in more complex codebases like the ones you&#x27;ll build for your projects: bugs can be far subtler, so getting comfortable with the debugger will save you significant time and tears!</p>
<h2 id="end"><a href="#end">End</a></h2>
<p>Congrats on finishing the Setup &amp; C++ lab! Now, it&#x27;s time to submit your code and get checked off by a TA. If you wish to have a deeper understanding of C++ or learn advanced C++ features to better your program design, you can find more information in our advanced C++ tutorial coming soon!</p>
<h2 id="submission"><a href="#submission">Submission</a></h2>
<p>Submit your GitHub link and commit ID to the &quot;Lab 1: Setup &amp; C++&quot; assignment on Gradescope, <strong>then get checked off by a TA at hours</strong>.</p>
<p>Reference the GitHub + Gradescope Guide <a href="/website-fall-23/docs/github-gradescope-guide#handing-in-assignments">here</a>.</p>
<div class="warning-callout callout"><p>You will not get credit for having completed the lab, unless you get it checked off!</p></div>
<hr class="footer-hr"/><p class="footer-p">Please let us know if you find any mistakes, inconsistencies, or confusing language in this or any other CS 1230 document by filling out our <a href="https://forms.gle/ZYY519pzSvu8YaZK6" target="_blank">anonymous feedback form</a>.</p><style>
mjx-container[jax=&quot;SVG&quot;] {
  direction: ltr;
}

mjx-container[jax=&quot;SVG&quot;] &gt; svg {
  overflow: visible;
  min-height: 1px;
  min-width: 1px;
}

mjx-container[jax=&quot;SVG&quot;] &gt; svg a {
  fill: blue;
  stroke: blue;
}

mjx-container[jax=&quot;SVG&quot;][display=&quot;true&quot;] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax=&quot;SVG&quot;][display=&quot;true&quot;][width=&quot;full&quot;] {
  display: flex;
}

mjx-container[jax=&quot;SVG&quot;][justify=&quot;left&quot;] {
  text-align: left;
}

mjx-container[jax=&quot;SVG&quot;][justify=&quot;right&quot;] {
  text-align: right;
}

g[data-mml-node=&quot;merror&quot;] &gt; g {
  fill: red;
  stroke: red;
}

g[data-mml-node=&quot;merror&quot;] &gt; rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node=&quot;mtable&quot;] &gt; line[data-line], svg[data-table] &gt; g &gt; line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node=&quot;mtable&quot;] &gt; rect[data-frame], svg[data-table] &gt; g &gt; rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node=&quot;mtable&quot;] &gt; .mjx-dashed, svg[data-table] &gt; g &gt; .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node=&quot;mtable&quot;] &gt; .mjx-dotted, svg[data-table] &gt; g &gt; .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node=&quot;mtable&quot;] &gt; g &gt; svg {
  overflow: visible;
}

[jax=&quot;SVG&quot;] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax=&quot;SVG&quot;] mjx-tool &gt; mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool &gt; mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node=&quot;maction&quot;][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

mjx-container[jax=&quot;SVG&quot;] path[data-c], mjx-container[jax=&quot;SVG&quot;] use[data-c] {
  stroke-width: 3;
}
</style></main></div>
        </div>
      <script id="vite-plugin-ssr_pageContext" type="application/json">{"pageContext":{"_pageId":"/pages/labs/lab1"}}</script><script type="module" src="/website-fall-23/assets/entry-client-routing.0fb0364c.js" async></script><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/pages/labs/lab1.page.10c43504.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/chunk-14d409af.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/chunk-66c40c41.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/chunk-b66c7dfa.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/renderer/_default.page.client.9e6448c1.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/entry-client-routing.0fb0364c.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/chunk-7f137163.js"></body>
    </html>