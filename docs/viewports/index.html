<!DOCTYPE html>
    <html lang="en">
      <head><link rel="stylesheet" type="text/css" href="/website-fall-23/assets/index.456f6971.css">
        <meta charset="UTF-8">
        <title>Viewports | CSCI 1230</title>
        <meta name="description" content="We teach computer graphics!">
        <meta name="keywords" content="Computer Science, Computer Graphics, CS 1230, CSCI 1230, Brown University, Providence">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-263NEZCW0C"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-263NEZCW0C');
        </script>
      </head>
      <body>
        <div id="root">
          <nav id="nav-bar"><div id="nav-bar-inner"><a id="logo" class="no-select" href="/website-fall-23/" aria-label="home" style="--duration:450ms"><div id="logo-box-1"></div><div id="logo-box-2"></div><div id="logo-box-3"></div><div id="logo-box-4"></div><div id="logo-box-5"></div><div id="logo-box-6"></div></a><div id="nav-items"><div id="nav-items-inner"><a href="/website-fall-23/" class="nav-item">Home</a><a href="/website-fall-23/docs" class="nav-item">Docs</a><a href="/website-fall-23/lectures" class="nav-item">Lectures</a><a href="/website-fall-23/labs" class="nav-item">Labs</a><a href="/website-fall-23/projects" class="nav-item">Projects</a></div></div></div></nav><div id="page" class=""><nav class="toc"><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#viewports">Viewports</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#recap-a-texture-in-an-fbo">Recap: A Texture In An FBO</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#clearing">Clearing</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#recap-the-canonical-view-volume">Recap: The Canonical View Volume</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#drawing">Drawing</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#setting-the-viewport">Setting The Viewport</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#getting-the-viewport">Getting The Viewport</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#putting-it-all-together">Putting It All Together</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#faq">FAQ</a></li></ol></li></ol></nav><main>
<!-- -->
<h1 id="viewports"><a href="#viewports">Viewports</a></h1>
<h2 id="recap-a-texture-in-an-fbo"><a href="#recap-a-texture-in-an-fbo">Recap: A Texture In An FBO</a></h2>
<p>Suppose there exists some <strong>texture</strong>—the color buffer of the currently-bound FBO.</p>
<figure id="figure-2" class="image-wrapper"><div class="image-grid" style="--target-width:35%"><a href="/website-fall-23/docs/viewports/texture.png" target="_blank" rel="noopener noreferrer"><img src="/docs/viewports/texture.png" alt="TODO"/></a></div><figcaption><strong>Figure 2: </strong>A texture.</figcaption></figure>
<p>If this was a texture that <em>you&#x27;d</em> previously created, then it&#x27;d have dimensions based on your call to <code>glTexImage2D()</code> (<a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml" target="_blank" rel="noopener noreferrer">docs</a>).</p>
<p>If this was the color buffer of the <strong>default FBO</strong>, however, it&#x27;d have dimensions corresponding to whatever OpenGL is rendering to. In fact, this texture would be exactly what&#x27;s rendered there.</p>
<p>But besides that, whether this is in the default FBO or one you&#x27;ve created is <strong>not important</strong>. All that matters is that we&#x27;ve got this here texture.</p>
<h2 id="clearing"><a href="#clearing">Clearing</a></h2>
<p>What happens when we call <code>glClear()</code>? Very simply, it&#x27;ll cause OpenGL to clear everything in the currently-bound FBO&#x27;s buffer(s), by filling it with some given value.</p>
<p>However, remember that an FBO can have <em>multiple</em> different buffers. We must therefore specify <strong>which one(s) to clear</strong> by calling <code>glClear()</code> with a <code>mask</code> argument (<a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glClear.xhtml" target="_blank" rel="noopener noreferrer">docs</a>). This is a bitwise OR of three masks that indicate the buffers to be cleared, and those masks are <code>GL_COLOR_BUFFER_BIT</code>, <code>GL_DEPTH_BUFFER_BIT</code>, and <code>GL_STENCIL_BUFFER_BIT</code>.</p>
<p>We can also specify <strong>what value(s) to clear the buffer(s) with</strong> using <code>glClearColor()</code>, <code>glClearDepth()</code>, and <code>glClearStencil()</code>. You&#x27;ll probably only have heard of the first one.</p>
<p>So let&#x27;s now suppose we use <code>glClear()</code> to clear our texture with a blue color. At the same time, we&#x27;ll also clear our depth buffer.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-en">glClearColor</span>(<span class="pl-c1">0</span>,<span class="pl-c1">0</span>,<span class="pl-c1">1</span>,<span class="pl-c1">1</span>);
</span><span class="code-line"><span class="pl-en">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
</span></code></pre>
<figure id="figure-3" class="image-wrapper"><div class="image-grid" style="--target-width:35%"><a href="/website-fall-23/docs/viewports/texture-cleared.png" target="_blank" rel="noopener noreferrer"><img src="/docs/viewports/texture-cleared.png" alt="TODO"/></a></div><figcaption><strong>Figure 3: </strong>A texture, cleared with blue.</figcaption></figure>
<h2 id="recap-the-canonical-view-volume"><a href="#recap-the-canonical-view-volume">Recap: The Canonical View Volume</a></h2>
<p>Here&#x27;s <strong>the canonical view volume</strong>. It is <em>always</em> a box of side-length 2, centered on the origin.</p>
<figure id="figure-1" class="image-wrapper"><div class="image-grid" style="--target-width:35%"><a href="/website-fall-23/docs/viewports/canonical-view-volume.png" target="_blank" rel="noopener noreferrer"><img src="/docs/viewports/canonical-view-volume.png" alt="TODO"/></a></div><figcaption><strong>Figure 1: </strong>The canonical view volume.</figcaption></figure>
<h2 id="drawing"><a href="#drawing">Drawing</a></h2>
<p>Suppose we&#x27;ve prepared something to draw (see labs 8-10 for details), and we&#x27;d like to draw it to our texture. Here, we have placed a green sphere in our canonical view volume:</p>
<figure id="figure-4" class="image-wrapper"><div class="image-grid" style="--target-width:35%"><a href="/website-fall-23/docs/viewports/green-sphere.png" target="_blank" rel="noopener noreferrer"><img src="/docs/viewports/green-sphere.png" alt="TODO"/></a></div><figcaption><strong>Figure 4: </strong>A green sphere, in the canonical view volume.</figcaption></figure>
<p>As we already know, we can call something like <code>glDrawArrays()</code> (<a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml" target="_blank" rel="noopener noreferrer">docs</a>) to render this sphere to the image in the Qt window that appears when we run our code.</p>
<p>Since that image is nothing more than a texture (in the default FBO), we can generalize the above statement: we use <code>glDrawArrays()</code> to render stuff in our <strong>canonical view volume</strong> to a <strong>texture</strong>.</p>
<h2 id="setting-the-viewport"><a href="#setting-the-viewport">Setting The Viewport</a></h2>
<p>But how do we know <em>where</em> (on our texture) we should draw our sphere? After all, our canonical view volume goes from <code>-1</code> to <code>1</code>, not <code>0</code> to <code>width</code> or anything like that.</p>
<p>This is where <code>glViewport()</code> (<a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glViewport.xhtml" target="_blank" rel="noopener noreferrer">docs</a>) comes in. It allows us to define a mapping like so:</p>
<figure id="figure-5" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><a href="/website-fall-23/docs/viewports/viewport-mapping.png" target="_blank" rel="noopener noreferrer"><img src="/docs/viewports/viewport-mapping.png" alt="TODO"/></a></div><figcaption><strong>Figure 5: </strong>The viewport maps a 2D coordinate range (in the xy plane of the canonical view volume&#x27;s space) to another 2D coordinate range (this time, in the texture&#x27;s coordinate space).</figcaption></figure>
<p>Typically, we&#x27;d specify our <code>glViewport()</code> arguments in such a way that the output 2D coordinate range matches our texture perfectly.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">int</span> x = <span class="pl-c1">0</span>;
</span><span class="code-line"><span class="pl-k">int</span> y = <span class="pl-c1">0</span>;
</span><span class="code-line"><span class="pl-k">int</span> w = textureWidth;
</span><span class="code-line"><span class="pl-k">int</span> h = textureHeight;
</span><span class="code-line highlight-line"><span class="pl-en">glViewport</span>(x, y, w, h);
</span></code></pre>
<blockquote>
<p>In fact, Qt does this behind the scenes for you just before each <code>paintGL()</code> call, using the default FBO&#x27;s texture&#x27;s dimensions. That&#x27;s why we didn&#x27;t have to do this before lab 11.</p>
</blockquote>
<p>But nothing&#x27;s stopping you from setting this any way you like:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-c">// Draw within a 400x400 square, with its bottom-left corner at (10,10)</span>
</span><span class="code-line highlight-line"><span class="pl-en">glViewport</span>(<span class="pl-c1">10</span>, <span class="pl-c1">10</span>, <span class="pl-c1">400</span>, <span class="pl-c1">400</span>);
</span></code></pre>
<h2 id="getting-the-viewport"><a href="#getting-the-viewport">Getting The Viewport</a></h2>
<p><code>glViewport()</code> lets us <em>set</em> the output viewport using <strong>4 integer values</strong>.</p>
<p>We can <em>get</em> the currently-set viewport values by calling:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">int</span> vp[<span class="pl-c1">4</span>] = {-<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>, -<span class="pl-c1">1</span>}; <span class="pl-c">// Dummy values</span>
</span><span class="code-line highlight-line"><span class="pl-en">glGet</span>(GL_VIEWPORT, vp);
</span><span class="code-line">
</span><span class="code-line">std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">&quot;</span>viewport: <span class="pl-pds">&quot;</span></span>
</span><span class="code-line">          &lt;&lt; <span class="pl-s"><span class="pl-pds">&quot;</span>x = <span class="pl-pds">&quot;</span></span> &lt;&lt; vp[<span class="pl-c1">0</span>] &lt;&lt; <span class="pl-s"><span class="pl-pds">&quot;</span>, <span class="pl-pds">&quot;</span></span>
</span><span class="code-line">          &lt;&lt; <span class="pl-s"><span class="pl-pds">&quot;</span>y = <span class="pl-pds">&quot;</span></span> &lt;&lt; vp[<span class="pl-c1">1</span>] &lt;&lt; <span class="pl-s"><span class="pl-pds">&quot;</span>, <span class="pl-pds">&quot;</span></span>
</span><span class="code-line">          &lt;&lt; <span class="pl-s"><span class="pl-pds">&quot;</span>w = <span class="pl-pds">&quot;</span></span> &lt;&lt; vp[<span class="pl-c1">2</span>] &lt;&lt; <span class="pl-s"><span class="pl-pds">&quot;</span>, <span class="pl-pds">&quot;</span></span>
</span><span class="code-line">          &lt;&lt; <span class="pl-s"><span class="pl-pds">&quot;</span>h = <span class="pl-pds">&quot;</span></span> &lt;&lt; vp[<span class="pl-c1">3</span>] &lt;&lt; std::endl;
</span></code></pre>
<div class="task-callout callout"><p>Suppose we&#x27;ve created a texture with width <code>600</code> and height <code>400</code>. We then set our clear color to blue and cleared that texture.</p><p>Right before we draw our green sphere to that texture, we call:</p><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-en">glViewport</span>(<span class="pl-c1">300</span>, <span class="pl-c1">200</span>, <span class="pl-c1">600</span>, <span class="pl-c1">400</span>);
</span></code></pre><p>What would our texture look like after the draw call finishes?</p><div class="table-wrapper"><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">b</th><th align="center">c</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><img src="/website-fall-23/docs/viewports/a1.png" alt="a1"/></td><td align="center"><img src="/website-fall-23/docs/viewports/b1.png" alt="b1"/></td><td align="center"><img src="/website-fall-23/docs/viewports/c1.png" alt="c1"/></td></tr><tr><td align="center">2</td><td align="center"><img src="/website-fall-23/docs/viewports/a2.png" alt="a2"/></td><td align="center"><img src="/website-fall-23/docs/viewports/b2.png" alt="b2"/></td><td align="center"><img src="/website-fall-23/docs/viewports/c2.png" alt="c2"/></td></tr></tbody></table></div><details><summary>Click here for the solution.</summary><p><strong>Answer</strong>:</p><p>b1.</p><p><strong>Explanation</strong>:</p><p><code>glClear()</code> will have cleared the <em>whole</em> texture with blue, not just the viewport area.</p><p><code>x</code> and <code>y</code> define the coordinates of the bottom-left corner of the viewport, so the image should start at <code>(300, 200)</code>.</p><p><code>w</code> and <code>h</code> define the width and height respectively, not the top-right coordinates.</p></details></div>
<h2 id="putting-it-all-together"><a href="#putting-it-all-together">Putting It All Together</a></h2>
<p>If you&#x27;ve made it this far, well, that&#x27;s about all we&#x27;ve got for you.</p>
<p>Assuming you understand <strong>texture-mapping</strong> and the concept of creating a rectangle which &quot;fills up&quot; the canonical view volume (i.e. a <strong>full-screen quad</strong>), you <em>might</em> already be sufficiently equipped to understand the diagram below, which depicts what&#x27;s happening in lab 11:</p>
<figure id="figure-6" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><a href="/website-fall-23/docs/viewports/full-diagram.png" target="_blank" rel="noopener noreferrer"><img src="/docs/viewports/full-diagram.png" alt="TODO"/></a></div><figcaption><strong>Figure 6: </strong><p>How most post-processing is done in real-time graphics: render <em>to</em> a texture, then render <em>from</em> that texture, by texture-mapping it onto a full-screen quad. On that second pass, you can use a <strong>fragment shader</strong> to apply post-processing effects.</p></figcaption></figure>
<p>If you still have any questions, that&#x27;s what Ed is for. Please ask your questions there, so that everyone else can benefit from the discussion!</p>
<p>We&#x27;ll move some of the more frequently-asked questions here:</p>
<h2 id="faq"><a href="#faq">FAQ</a></h2>
<details><summary>Why must I multiply by <code>devicePixelRatio()</code>?</summary><p>Thanks to the likes of <strong>high-resolution displays</strong> (like Apple&#x27;s Retina screens), there&#x27;s a difference between <em>logical</em> pixels and <em>physical</em> pixels.</p><div class="success-callout callout"><p>Logical pixels are roughly the same visual size across devices. Physical pixels are the size of the actual hardware pixels on the device.</p><p>The number of physical pixels per logical pixel is described by the device&#x27;s pixel ratio.</p></div><p>Unfortunately for us, <code>size()</code> returns dimensions in terms of <em>logical</em> pixels, but textures (such as the default FBO&#x27;s color buffer, aka your output image) are defined in terms of <em>physical</em> pixels. Thus, we must scale our dimensions as such:</p><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">int</span> physWidth  = size().width() * <span class="pl-en">devicePixelRatio</span>();
</span><span class="code-line"><span class="pl-k">int</span> physHeight = size().width() * <span class="pl-en">devicePixelRatio</span>();
</span><span class="code-line"><span class="pl-en">glViewport</span>(<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, physWidth, physHeight);
</span></code></pre></details>
<details><summary>What&#x27;s going on with Windows computers and scaling?</summary><p>On Windows operating systems, it&#x27;s possible to scale the display by some amount (e.g. <code>150%</code>) via user preferences.</p><p>Unfortunately for us (again), this causes the default FBO&#x27;s color buffer&#x27;s dimensions to stray even further away from the dimensions returned by <code>size()</code>. That texture&#x27;s dimensions are now additionally scaled by the user&#x27;s display scaling factor, e.g. <code>1.5</code> times.</p><p>A naïve solution would be to additionally multiply by this factor:</p><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-c">// Assuming the user&#x27;s display is scaled to 150%</span>
</span><span class="code-line"><span class="pl-k">int</span> physWidth  = size().width() * <span class="pl-en">devicePixelRatio</span>() * 1.5;
</span><span class="code-line"><span class="pl-k">int</span> physHeight = size().width() * <span class="pl-en">devicePixelRatio</span>() * 1.5;
</span><span class="code-line"><span class="pl-en">glViewport</span>(<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, physWidth, physHeight);
</span></code></pre><p>However, this isn&#x27;t a very portable solution. This code will produce undesirable output on a Windows machine with a different scaling factor, or on an Mac.</p><div class="success-callout callout"><p>A better approach would be to add this line to the beginning of <code>main()</code>:</p><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-en">QGuiApplication::setHighDpiScaleFactorRoundingPolicy</span>(Qt::HighDpiScaleFactorRoundingPolicy::Floor);
</span></code></pre><p>But we&#x27;re not confident in our ability to explain why this works just yet.</p></div></details>
<details><summary>Wait, Qt sets the viewport between <code>paintGL()</code> calls? Why do we need to do it, then?</summary><figure id="figure-7" class="image-wrapper"><div class="image-grid" style="--target-width:35%"><a href="/website-fall-23/docs/viewports/you-dont.png" target="_blank" rel="noopener noreferrer"><img src="/docs/viewports/you-dont.png" alt="TODO"/></a></div><figcaption><strong>Figure 7: </strong><p>Thats the neat thing. You don&#x27;t! <strong>(Conditionally)</strong></p></figcaption></figure><p><em>If</em> (1) your intermediate textures are all the <strong>same physical pixel size</strong> as your final output texture, <em>and</em> (2) you&#x27;re rendering to the entirety of each texture, then it&#x27;s true that you don&#x27;t actually have to call <code>glViewport()</code> yourself. This is because, as mentioned earlier:</p><blockquote>
<p>Qt calls <code>glViewport()</code> behind the scenes for you just before each <code>paintGL()</code> call, using the default FBO&#x27;s texture&#x27;s dimensions.</p>
</blockquote><p>So, in lab 11, calling <code>glViewport()</code> was a purely pedagogical exercise!</p><div class="error-callout callout"><p>This is only true if both conditions (1) and (2) above are met. One thing that&#x27;s likely to trip you up, if you choose to attempt this, is the use of the correct <strong>physical pixel size</strong> for intermediate textures.</p></div></details>
<details><summary>When might we set <code>glViewport()</code> to something other than the dimensions of the texture we&#x27;re drawing to?</summary><p>We might use it for a cheap <strong>split-screen</strong> effect. This is actually used for, say, drawing to 3DS Max screens, which are two-part.</p><figure id="figure-8" class="image-wrapper"><div class="image-grid" style="--target-width:100%"><a href="/website-fall-23/docs/viewports/split-screen.png" target="_blank" rel="noopener noreferrer"><img src="/docs/viewports/split-screen.png" alt="TODO"/></a></div><figcaption><strong>Figure 8: </strong><p>Cheap split-screen effect achieved by drawing four times in <code>paintGL()</code>, using different viewports each time. Screenshot shows modified lab 10 code.</p></figcaption></figure><p>Another use case might be for a simple <strong>pixelation</strong> filter, when combined with nearest-neighbor interpolation.</p></details>
<hr class="footer-hr"/><p class="footer-p">Please let us know if you find any mistakes, inconsistencies, or confusing language in this or any other CS 1230 document by filling out our <a href="https://forms.gle/ZYY519pzSvu8YaZK6" target="_blank">anonymous feedback form</a>.</p></main></div>
        </div>
      <script id="vite-plugin-ssr_pageContext" type="application/json">{"pageContext":{"_pageId":"/pages/docs/viewports"}}</script><script type="module" src="/website-fall-23/assets/entry-client-routing.4bcc9d68.js" async></script><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/pages/docs/viewports.page.61a17d6d.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/chunk-14d409af.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/chunk-66c40c41.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/chunk-b66c7dfa.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/renderer/_default.page.client.9e6448c1.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/entry-client-routing.4bcc9d68.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/chunk-7f137163.js"></body>
    </html>