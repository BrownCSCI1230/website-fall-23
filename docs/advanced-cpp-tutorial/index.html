<!DOCTYPE html>
    <html lang="en">
      <head><link rel="stylesheet" type="text/css" href="/website-fall-23/assets/index.456f6971.css">
        <meta charset="UTF-8">
        <title>Going Deeper with C++ | CSCI 1230</title>
        <meta name="description" content="We teach computer graphics!">
        <meta name="keywords" content="Computer Science, Computer Graphics, CS 1230, CSCI 1230, Brown University, Providence">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-263NEZCW0C"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-263NEZCW0C');
        </script>
      </head>
      <body>
        <div id="root">
          <nav id="nav-bar"><div id="nav-bar-inner"><a id="logo" class="no-select" href="/website-fall-23/" aria-label="home" style="--duration:450ms"><div id="logo-box-1"></div><div id="logo-box-2"></div><div id="logo-box-3"></div><div id="logo-box-4"></div><div id="logo-box-5"></div><div id="logo-box-6"></div></a><div id="nav-items"><div id="nav-items-inner"><a href="/website-fall-23/" class="nav-item">Home</a><a href="/website-fall-23/docs" class="nav-item">Docs</a><a href="/website-fall-23/lectures" class="nav-item">Lectures</a><a href="/website-fall-23/labs" class="nav-item">Labs</a><a href="/website-fall-23/projects" class="nav-item">Projects</a></div></div></div></nav><div id="page" class=""><nav class="toc"><ol class="toc-level toc-level-1"><li class="toc-item toc-item-h1"><a class="toc-link toc-link-h1" href="#going-deeper-with-c">Going Deeper with C++</a><ol class="toc-level toc-level-2"><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#dynamic-memory-allocation">Dynamic Memory Allocation</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#smart-pointers">Smart Pointers</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#operator-overloading">Operator Overloading</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#lambda-expressions">Lambda Expressions</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#runtime-polymorphism">Runtime Polymorphism</a><ol class="toc-level toc-level-3"><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#function-type-proxies">Function Type Proxies</a></li><li class="toc-item toc-item-h3"><a class="toc-link toc-link-h3" href="#virtual-functions">Virtual Functions</a></li></ol></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#pointers-and-references-reprise">Pointers and References (Reprise)</a></li><li class="toc-item toc-item-h2"><a class="toc-link toc-link-h2" href="#pointer-arithmetic">Pointer Arithmetic</a></li></ol></li></ol></nav><main>
<!-- -->
<h1 id="going-deeper-with-c"><a href="#going-deeper-with-c">Going Deeper with C++</a></h1>
<p>In lab 1, we introduced you to the minimum C++ features you&#x27;ll need for programming work in this course.
In this document, we cover additional C++ features you can use to improve your program design.
We&#x27;ll also talk a bit about things happening &quot;under the hood&quot; for you to have a deeper understanding of how the language works. C++ is a huge, featureful language, so we&#x27;re not attempting to cover <em>everything</em> that&#x27;s possible within the language. Rather, we&#x27;ve picked a handful of topics that we think may be most useful for the work you do in this course.</p>
<h2 id="dynamic-memory-allocation"><a href="#dynamic-memory-allocation">Dynamic Memory Allocation</a></h2>
<p>Consider the following code:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">struct</span> <span class="pl-en">Person</span> {
</span><span class="code-line">    std::string name;
</span><span class="code-line">    <span class="pl-k">unsigned</span> <span class="pl-k">int</span> age;
</span><span class="code-line">};
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">void</span> <span class="pl-en">doStuff</span>() {
</span><span class="code-line">    Person arvind = { .<span class="pl-smi">name</span> = <span class="pl-s"><span class="pl-pds">&quot;</span>Arvind<span class="pl-pds">&quot;</span></span>, .<span class="pl-smi">age</span> = <span class="pl-c1">20</span> };
</span><span class="code-line">    Person maya = { .<span class="pl-smi">name</span> = <span class="pl-s"><span class="pl-pds">&quot;</span>Maya<span class="pl-pds">&quot;</span></span>, .<span class="pl-smi">age</span> = <span class="pl-c1">21</span> };
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-c">// ...</span>
</span><span class="code-line">}
</span><span class="code-line">}
</span></code></pre>
<p>In this example, the compiler knows how big a <code>Person</code> object is (i.e. how much memory it takes up), so it allocates enough memory on the stack to store these two <code>Person</code> objects.</p>
<p>But what if we don&#x27;t know how many <code>Person</code> objects we&#x27;ll need to create at compile time? For example, imagine the scenario where we need to load a list of people from a file on disk. The standard way to handle this situation would be to put the <code>Person</code> objects in an <code>std::vector</code>:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">void</span> <span class="pl-en">doStuff</span>() {
</span><span class="code-line">    std::vector&lt;Person&gt; people;
</span><span class="code-line">    <span class="pl-c1">loadFromFile</span>(<span class="pl-s"><span class="pl-pds">&quot;</span>people.txt<span class="pl-pds">&quot;</span></span>, people);
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-c">// ...</span>
</span><span class="code-line">}
</span></code></pre>
<p>But how is <code>std::vector</code> actually implemented? It can&#x27;t possibly be storing its objects on the stack, because the compiler doesn&#x27;t know in advance how much stack space to allocate. Internally, <code>std::vector</code> is <em>dynamically allocating</em> memory on the heap to store these objects. In C++, you can dynamically allocate memory using the <code>new</code> operator. Here&#x27;s how we would rewrite the above example to use <code>new</code> directly, instead of relying on <code>std::vector</code>:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">void</span> <span class="pl-en">doStuff</span>() {
</span><span class="code-line">    <span class="pl-c">// Allocate enough memory on the heap to store all the people in the text file</span>
</span><span class="code-line">    <span class="pl-k">int</span> numPeople = <span class="pl-c1">numberOfLines</span>(<span class="pl-s"><span class="pl-pds">&quot;</span>people.txt<span class="pl-pds">&quot;</span></span>);
</span><span class="code-line">    <span class="pl-k">auto</span> people = <span class="pl-k">new</span> Person[numPeople];
</span><span class="code-line">    <span class="pl-c1">loadFromFile</span>(<span class="pl-s"><span class="pl-pds">&quot;</span>people.txt<span class="pl-pds">&quot;</span></span>, people);
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-c">// ...</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-k">delete[]</span> people;
</span><span class="code-line">}
</span></code></pre>
<p>The syntax <code>new Person[numPeople]</code> means &quot;allocate a continguous block of memory on the heap that can store <code>numPeople</code> instances of the <code>Person</code> object.&quot;
If you only wanted to allocate a single <code>Person</code> object, the syntax looks a little simpler:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">void</span> <span class="pl-en">doStuff</span>() {
</span><span class="code-line">    <span class="pl-k">auto</span> person = <span class="pl-k">new</span> Person{ .<span class="pl-smi">name</span> = <span class="pl-s"><span class="pl-pds">&quot;</span>Arvind<span class="pl-pds">&quot;</span></span>, .<span class="pl-smi">age</span> = <span class="pl-c1">20</span> };
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-c">// ...</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-k">delete</span> person;
</span><span class="code-line">}
</span></code></pre>
<p>Note, in both cases, the presence of the <code>delete</code> operator at the end of the code. This is necessary because the compiler doesn&#x27;t know when you&#x27;re done using the memory you&#x27;ve allocated on the heap. If you don&#x27;t explicitly <code>delete</code> the memory you&#x27;ve allocated, it will stay allocated until the program exits, a situation known as a <em>memory leak</em>. Memory leaks are bad: in the worst case, they can cause your program to run out of memory and crash. In the best case, your program uses more memory than it needs to, which can cause performance problems (slowing down your computer; wasting battery life on laptops and mobile devices).</p>
<p>Managing dynamically-allocated memory manually with <code>new</code> and <code>delete</code> can be tricky, because you have to remember to <code>delete</code> every object you <code>new</code>-ed, and you have to make sure you don&#x27;t <code>delete</code> an object more than once. If you forget to <code>delete</code> an object, you have a memory leak. If you <code>delete</code> an object more than once, you have a <em>double free</em> error: your program can crash when it tries to access memory that&#x27;s no longer allocated to it. These bugs can be so gnarly that we decided not even to teach you how to use <code>new</code> and <code>delete</code> in lab 1. Instead, we taught you how to use <code>std::vector</code>, which manages memory for you automatically. You can absolutely get by using <code>std::vector</code> for all your dynamic memory needs in this course, if you like.
There are reasons you might want to dynamically allocate memory yourself, though (like the <a href="#virtual-functions">virtual function-based runtime polymorphism</a> that we discuss later in this document).</p>
<h3 id="smart-pointers"><a href="#smart-pointers">Smart Pointers</a></h3>
<p>The C++ standard library has some features that make it easier to manage dynamic memory. In particular, it provides <em>smart pointers</em>: objects that behave like pointers, but automatically manage the memory they point to. For example:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">void</span> <span class="pl-en">doStuff</span>() {
</span><span class="code-line">    <span class="pl-k">auto</span> person = std::unique_ptr&lt;Person&gt;{
</span><span class="code-line">        <span class="pl-k">new</span> Person{ .<span class="pl-smi">name</span> = <span class="pl-s"><span class="pl-pds">&quot;</span>Arvind<span class="pl-pds">&quot;</span></span>, .<span class="pl-smi">age</span> = <span class="pl-c1">20</span> }
</span><span class="code-line">    };
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-c">// ...</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-c">// No need to explicitly delete the person object;</span>
</span><span class="code-line">    <span class="pl-c">// it will be deleted automatically when the unique_ptr goes out of scope.</span>
</span><span class="code-line">}
</span></code></pre>
<p><code>unique_ptr</code> is so named because you can have only one <code>unique_ptr</code> referring to a particular object at a time. If you try to copy a <code>unique_ptr</code>, the compiler will give you an error:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">void</span> <span class="pl-en">doStuff</span>() {
</span><span class="code-line">    <span class="pl-k">auto</span> person = std::unique_ptr&lt;Person&gt;{
</span><span class="code-line">        <span class="pl-k">new</span> Person{ .<span class="pl-smi">name</span> = <span class="pl-s"><span class="pl-pds">&quot;</span>Arvind<span class="pl-pds">&quot;</span></span>, .<span class="pl-smi">age</span> = <span class="pl-c1">20</span> }
</span><span class="code-line">    };
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-c">// ...</span>
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-k">auto</span> person2 = person; <span class="pl-c">// error: cannot copy a unique_ptr</span>
</span><span class="code-line">}
</span></code></pre>
<p>If you have a situation where you need multiple variables referring to the same dynamic object, the standard library provides another smart pointer type, <code>shared_ptr</code>, which allows this. There is also a third smart pointer type, <code>weak_ptr</code>, which is sometimes necessary to use in conjuction with <code>shared_ptr</code>. We won&#x27;t talk about <code>shared_ptr</code> and <code>weak_ptr</code> in this document, but you can read more about them <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr" target="_blank" rel="noopener noreferrer">here</a> and <a href="https://en.cppreference.com/w/cpp/memory/weak_ptr" target="_blank" rel="noopener noreferrer">here</a>, if you&#x27;re interested.</p>
<details><summary>For those interested in programming language implementation:</summary><p><code>shared_ptr</code> implements a form of <a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="noopener noreferrer">reference counting</a>, which is a type of automatic memory management algorithm used by some programming languages that do not allow manual memory management (e.g. Python). Such automatic memory management algorithms are also known as <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener noreferrer">garbage collection</a> algorithms.</p></details>
<h2 id="operator-overloading"><a href="#operator-overloading">Operator Overloading</a></h2>
<p>Object-oriented programming is great, but writing out long method names when calling functions on objects can be tedious. For example, if have a <code>vec3</code> class representing a 3D vector, and I want to add three vectors together, it&#x27;s both tedious to type and hard to read if I have to write the code like this:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> v1 = vec3{ <span class="pl-c1">1.1</span>, <span class="pl-c1">4.2</span>, <span class="pl-c1">2.5</span> };
</span><span class="code-line"><span class="pl-k">auto</span> v2 = vec3{ <span class="pl-c1">0.4</span>, <span class="pl-c1">2.6</span>, <span class="pl-c1">3.1</span> };
</span><span class="code-line"><span class="pl-k">auto</span> v3 = vec3{ <span class="pl-c1">2.3</span>, <span class="pl-c1">1.2</span>, <span class="pl-c1">0.5</span> };
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> v4 = v1.add(v2).add(v3);
</span></code></pre>
<p>Wouldn&#x27;t it be nice if we could just write <code>v1 + v2 + v3</code> instead? We can, using a feature of C++ called <em>operator overloading</em>:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">struct</span> <span class="pl-en">vec3</span> {
</span><span class="code-line">    <span class="pl-k">double</span> x;
</span><span class="code-line">    <span class="pl-k">double</span> y;
</span><span class="code-line">    <span class="pl-k">double</span> z;
</span><span class="code-line">
</span><span class="code-line">    vec3 <span class="pl-k">operator</span>+(<span class="pl-k">const</span> vec3&amp; other) {
</span><span class="code-line">        <span class="pl-k">return</span> vec3{
</span><span class="code-line">            .<span class="pl-smi">x</span> = x + other.<span class="pl-smi">x</span>,
</span><span class="code-line">            .<span class="pl-smi">y</span> = y + other.<span class="pl-smi">y</span>,
</span><span class="code-line">            .<span class="pl-smi">z</span> = z + other.<span class="pl-smi">z</span>
</span><span class="code-line">        };
</span><span class="code-line">    }
</span><span class="code-line">};
</span></code></pre>
<p>There are <em>tons</em> of operators that you can overload in C++: the assignment operator <code>=</code>; the array subscript operator <code>[]</code>; even the &quot;deference pointer to object and call method&quot; operator <code>-&gt;</code> (which is how smart pointers are implemented, by the way). You can find a list of them <a href="https://en.cppreference.com/w/cpp/language/operators" target="_blank" rel="noopener noreferrer">here</a>.</p>
<h2 id="lambda-expressions"><a href="#lambda-expressions">Lambda Expressions</a></h2>
<p>Lambda expressions are one of the most important constructs in modern C++. It is what makes functional programming possible in the language, and it can be handy even for non-functional designs.
In other languages, lambdas are also known as <em>anonymous functions</em> or <em>closures</em>.
They can appear almost anywhere in your program: unlike regular functions, which may <strong>not</strong> appear inside other functions, lambdas can appear in any scope just like other primitives of the language such as an <code>int</code> or a <code>float</code>. You may assign lambdas to variables and pass them around as parameters or return values. The lambda syntax looks very similar to functions, with the addition of a <strong>capture list</strong>:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-c">// Lambda syntax: [capture list](parameter list) { function body }</span>
</span><span class="code-line"><span class="pl-c">// the parameter list can be omitted if the lambda takes no arguments.</span>
</span><span class="code-line"><span class="pl-k">auto</span> identity = [](<span class="pl-k">auto</span> x) { <span class="pl-k">return</span> x; }; <span class="pl-c">// Must use type &quot;auto&quot; for a variable to which a lambda expression is assigned.</span>
</span><span class="code-line"><span class="pl-k">auto</span> x = identity(<span class="pl-c1">42</span>); <span class="pl-c">// x = 42</span>
</span></code></pre>
<p>The capture list controls how the lambda accesses variables in its surrounding scope. An empty capture list indicates that the lambda has no access to its surrounding scope. If access to the surrounding scope is required, the lambda may capture all the variables in its scope by value (<code>=</code>) or by reference (<code>&amp;</code>):</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> x = <span class="pl-c1">42</span>;
</span><span class="code-line"><span class="pl-k">auto</span> f = [=] { std::cout &lt;&lt; x; }; <span class="pl-c">// captures x by value, this makes a copy of x in f.</span>
</span><span class="code-line"><span class="pl-k">auto</span> g = [&amp;] { ++x; }; <span class="pl-c">// captures x by reference, x in the outer scope will be affected when g is called.</span>
</span><span class="code-line"><span class="pl-k">auto</span> h = [] { <span class="pl-c">/* cannot access x here */</span> }; <span class="pl-c">// captures nothing.</span>
</span><span class="code-line">
</span><span class="code-line"><span class="pl-en">f</span>(); <span class="pl-c">// prints 42</span>
</span><span class="code-line"><span class="pl-en">g</span>(); <span class="pl-c">// now x = 43</span>
</span></code></pre>
<p>The capture list can also be more specific, if desired. Something like <code>[&amp;, x]</code> means <code>x</code> is captured by value and everything else is captured by reference. <code>[=, &amp;x]</code> on the other hand, means <code>x</code> is captured by reference and everything else is captured by value.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> x = <span class="pl-c1">42</span>;
</span><span class="code-line"><span class="pl-k">auto</span> y = <span class="pl-c1">2.71</span>;
</span><span class="code-line"><span class="pl-k">auto</span> z = <span class="pl-s"><span class="pl-pds">&quot;</span>aaa<span class="pl-pds">&quot;</span></span>;
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> f = [&amp;, x]() <span class="pl-k">mutable</span> { ++x; }; <span class="pl-c">// x captured by value, y and z captured by reference. The “mutable” specifier is required if you need to modify something captured by value.</span>
</span><span class="code-line"><span class="pl-k">auto</span> g = [=, &amp;x] {}; <span class="pl-c">// x captured by reference, y and z captured by value.</span>
</span></code></pre>
<p>Determining the best way to capture can be tricky.
For example, capturing by reference incorrectly can lead to <em>dangling references</em>:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">f</span>() {
</span><span class="code-line">    <span class="pl-k">auto</span> x = <span class="pl-c1">42</span>;
</span><span class="code-line">    <span class="pl-k">return</span> [&amp;] { ++x; }; <span class="pl-c">// dangling reference here: by the time that the lambda is returned, the local variable x that it references is already released.</span>
</span><span class="code-line">}
</span></code></pre>
<p>As a rule of thumb, we recommend to capture by reference if the lambda is invoked within the scope where it’s defined and to capture by value if the lambda outlives the current scope (e.g. if the lambda is returned from a function).</p>
<p>Lambdas are useful for all sorts of things. Here&#x27;s a common use case: defining a custom sorting function for a vector of objects.
For example, if we have a vector of <code>Person</code> objects, we might want to sort them by their age:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">struct</span> <span class="pl-en">Person</span> {
</span><span class="code-line">    std::string name;
</span><span class="code-line">    <span class="pl-k">unsigned</span> <span class="pl-k">int</span> age;
</span><span class="code-line">};
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> people = std::vector&lt;Person&gt;{ <span class="pl-c">/* ... */</span> };  <span class="pl-c">// Populate list of people</span>
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// Sort people by age</span>
</span><span class="code-line"><span class="pl-c">// The sort function takes three arguments: the beginning and end of the range to sort, and a function that compares two elements.</span>
</span><span class="code-line"><span class="pl-en">std::sort</span>(people.begin(), people.end(),
</span><span class="code-line">[](<span class="pl-k">const</span> Person&amp; a, <span class="pl-k">const</span> Person&amp; b) {
</span><span class="code-line">    <span class="pl-k">return</span> a.<span class="pl-smi">age</span> &lt; b.<span class="pl-smi">age</span>;
</span><span class="code-line">});
</span></code></pre>
<h2 id="runtime-polymorphism"><a href="#runtime-polymorphism">Runtime Polymorphism</a></h2>
<p><em>Polymorphism</em> refers to the same code being able to operate on different data types.
Needing to do this is so common that any general-purpose programming language worth its salt will implement some form of polymorphism.
You already saw one form of polymorphism in lab 1: generic functions (i.e. functions with <code>auto</code> parameters, a.k.a function templates), which is known more broadly as <em>parametric polymorphism</em>.
While this kind of polymorphism is useful, it has some limitations.
Each time you call a generic function, the compiler checks the types of the arguments you&#x27;re passing to it and generates a new version of the function that&#x27;s specialized to those types.
This means that those types must be known at compile time...and this isn&#x27;t always the case.
Sometimes, you&#x27;ll need to write code that can handle multiple types of objects, but those types are only known at runtime--this is known as <em>runtime polymorphism</em>.
Consider the following example:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-c">// Declare a vector which will hold some objects.</span>
</span><span class="code-line"><span class="pl-k">auto</span> objects = std::vector&lt;??&gt;{};
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// Load a list of object type ids from a file.</span>
</span><span class="code-line">std::vector&lt;<span class="pl-k">int</span>&gt; ids = loadFromFile(<span class="pl-s"><span class="pl-pds">&quot;</span>objectTypes.txt<span class="pl-pds">&quot;</span></span>);
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// Populate &#x27;objects&#x27; with objects of the correct type,</span>
</span><span class="code-line"><span class="pl-c">// according to the ids loaded from the file.</span>
</span><span class="code-line"><span class="pl-k">for</span> (<span class="pl-k">auto</span> id : ids) {
</span><span class="code-line">    <span class="pl-k">switch</span> (id) {
</span><span class="code-line">        <span class="pl-k">case</span> <span class="pl-c1">0</span>: objects.<span class="pl-c1">emplace_back</span>(Rectangle{ .<span class="pl-smi">width</span> = <span class="pl-c1">2</span>, height = <span class="pl-c1">3</span> }); <span class="pl-k">break</span>;
</span><span class="code-line">        <span class="pl-k">case</span> <span class="pl-c1">1</span>: objects.<span class="pl-c1">emplace_back</span>(Circle{ .<span class="pl-smi">radius</span> = <span class="pl-c1">1</span> }); <span class="pl-k">break</span>;
</span><span class="code-line">        <span class="pl-c">// ...</span>
</span><span class="code-line">    }
</span><span class="code-line">}
</span></code></pre>
<p>We need to be able to store multiple types of objects in the <code>objects</code> vector...so what type should we replace <code>??</code> with?
Essentially, we need to create some kind of <em>proxy</em> type <code>T</code> that can represent any of the types we want to store in the vector. In the above example, <code>T</code> would be something like <code>Shape</code>.</p>
<p>If you&#x27;re familiar with Java, you&#x27;ve seen this design pattern before with Java&#x27;s object-oriented programming features (in particular, the <code>interface</code> construct).
C++, being the complex beast that it is, has multiple ways to achieve the same behavior. We&#x27;ll talk about two of them here: function type proxies and virtual functions.
The latter is the &quot;traditional&quot; way of achieving runtime polymorphism in C++ code (older versions of this course taught it exclusively and used it in stencil code), but it has some downsides that can make it inconvenient to use (more on this later). Thus, we talk about function type proxies first, because they are more straightforward.</p>
<h3 id="function-type-proxies"><a href="#function-type-proxies">Function Type Proxies</a></h3>
<p>Suppose that the only thing we need to be able to do with our shape objects is render them to some <code>Canvas</code> object. Then we could use the <em>type signature of this render function</em> as our proxy type, and we&#x27;d define our shape types using lambdas:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">using</span> RenderSignature = <span class="pl-k">auto</span>(<span class="pl-k">const</span> Canvas&amp;)-&gt;<span class="pl-k">void</span>;
</span><span class="code-line"><span class="pl-k">using</span> Shape = std::function&lt;RenderSignature&gt;;
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">Rectangle</span>(<span class="pl-k">int</span> width, height) {
</span><span class="code-line">    <span class="pl-k">return</span> [=](<span class="pl-k">const</span> Canvas&amp; canvas) {
</span><span class="code-line">        <span class="pl-c">// render the rectangle to the canvas</span>
</span><span class="code-line">    };
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">Circle</span>(<span class="pl-k">int</span> radius) {
</span><span class="code-line">    <span class="pl-k">return</span> [=](<span class="pl-k">const</span> Canvas&amp; canvas) {
</span><span class="code-line">        <span class="pl-c">// render the circle to the canvas</span>
</span><span class="code-line">    };
</span><span class="code-line">}
</span></code></pre>
<p>Since the lambdas returned by the <code>Rectangle</code> and <code>Circle</code> functions have the same type signature as <code>RenderSignature</code>, we can assign them to variables of type <code>Shape</code> and store them in a vector of <code>Shape</code>. Note that our use of the <code>=</code> capture mode allows the returned lambdas to capture the arguments to the shape constructors (e.g. <code>width</code>, <code>height</code>) by value, so that they can be used later when the lambdas are called.</p>
<p>If each shape type has multiple functions that we need to be able to call, then we can package these functions into a <code>struct</code> and use the type of that <code>struct</code> as our proxy type.
For example, let&#x27;s say that we want to be able to render shapes and also compute their areas:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">using</span> RenderSignature = <span class="pl-k">auto</span>(<span class="pl-k">const</span> Canvas&amp;)-&gt;<span class="pl-k">void</span>;
</span><span class="code-line"><span class="pl-k">using</span> AreaSignature = <span class="pl-k">auto</span>()-&gt;<span class="pl-k">double</span>;
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">struct</span> <span class="pl-en">Shape</span> {
</span><span class="code-line">    std::function&lt;RenderSignature&gt; render;
</span><span class="code-line">    std::function&lt;AreaSignature&gt; area;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">Rectangle</span>(<span class="pl-k">int</span> width, <span class="pl-k">int</span> height) {
</span><span class="code-line">    <span class="pl-k">return</span> Shape{
</span><span class="code-line">        [=](<span class="pl-k">const</span> Canvas&amp; canvas) {
</span><span class="code-line">            <span class="pl-c">// render the rectangle to the canvas</span>
</span><span class="code-line">        },
</span><span class="code-line">        [=]() {
</span><span class="code-line">            <span class="pl-c">// compute the area of the rectangle</span>
</span><span class="code-line">            <span class="pl-k">return</span> width*height;
</span><span class="code-line">        }
</span><span class="code-line">    };
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">Circle</span>(<span class="pl-k">int</span> radius) {
</span><span class="code-line">    <span class="pl-k">return</span> Shape{
</span><span class="code-line">        [=](<span class="pl-k">const</span> Canvas&amp; canvas) {
</span><span class="code-line">            <span class="pl-c">// render the circle to the canvas</span>
</span><span class="code-line">        },
</span><span class="code-line">        [=]() {
</span><span class="code-line">            <span class="pl-c">// compute the area of the circle</span>
</span><span class="code-line">            <span class="pl-k">return</span> <span class="pl-c1">3.14</span>*radius*radius;
</span><span class="code-line">        }
</span><span class="code-line">    };
</span><span class="code-line">}
</span></code></pre>
<h3 id="virtual-functions"><a href="#virtual-functions">Virtual Functions</a></h3>
<p>Lambdas are a relatively new feature of C++: they were introduced in the C++11 standard (so named because it was released in 2011), but the C++ language has been around for a lot longer (since 1985).
Before lambdas, we couldn&#x27;t pass functions around as data, so we couldn&#x27;t use the function type proxy design pattern described above. Instead, we had to use a different design pattern: <em>virtual functions</em>.</p>
<p>Virtual functions are one of C++&#x27;s built-in object-oriented programming features.
A virtual function is a function defined in a struct/class whose behavior can be overridden by child structs/classes.
Here is the same <code>Shape</code> example from above, rewritten to use virtual functions:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line">
</span><span class="code-line"><span class="pl-k">class</span> <span class="pl-en">Shape</span> {
</span><span class="code-line"><span class="pl-k">public:</span>
</span><span class="code-line">    <span class="pl-c">// The &quot;= 0;&quot; at the end of a function declaration means that</span>
</span><span class="code-line">    <span class="pl-c">//   the function is &quot;pure virtual&quot;, i.e. it has no implementation in this base class.</span>
</span><span class="code-line">    <span class="pl-c">// This is similar to Java&#x27;s &quot;abstract&quot; keyword for methods.</span>
</span><span class="code-line">    <span class="pl-k">virtual</span> <span class="pl-k">auto</span> <span class="pl-en">render</span>(<span class="pl-k">const</span> Canvas&amp; canvas)-&gt;void = 0;
</span><span class="code-line">    <span class="pl-k">virtual</span> <span class="pl-k">auto</span> <span class="pl-en">area</span>()-&gt;double = 0;
</span><span class="code-line">    <span class="pl-c">// A class with virtual functions must declare a virtual destructor</span>
</span><span class="code-line">    <span class="pl-k">virtual</span> <span class="pl-en">~Shape</span>() = <span class="pl-k">default</span>;
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// &quot;: public Shape&quot; means that Rectangle inherits from Shape</span>
</span><span class="code-line"><span class="pl-k">class</span> <span class="pl-en">Rectangle</span> : <span class="pl-k">public</span> <span class="pl-en">Shape</span> {
</span><span class="code-line"><span class="pl-k">public:</span>
</span><span class="code-line">    <span class="pl-k">double</span> width;
</span><span class="code-line">    <span class="pl-k">double</span> height;
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-c">// Why are we explicitly defining such a simple constructor here?</span>
</span><span class="code-line">    <span class="pl-c">// Why not just use aggregate initialization?</span>
</span><span class="code-line">    <span class="pl-c">// More on this later...</span>
</span><span class="code-line">    <span class="pl-en">Rectangle</span>(<span class="pl-k">double</span> _width, <span class="pl-k">double</span> _height): width{ _width }, height{ _height } {}
</span><span class="code-line">    <span class="pl-c">// Override the virtual destructor from the base class</span>
</span><span class="code-line">    <span class="pl-en">~Rectangle</span>() <span class="pl-k">override</span> = <span class="pl-k">default</span>;
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-k">auto</span> <span class="pl-en">render</span>(<span class="pl-k">const</span> Canvas&amp; canvas)-&gt;void <span class="pl-k">override</span> {
</span><span class="code-line">        <span class="pl-c">// render the rectangle to the canvas</span>
</span><span class="code-line">    }
</span><span class="code-line">    <span class="pl-k">auto</span> <span class="pl-en">area</span>()-&gt;double <span class="pl-k">override</span> {
</span><span class="code-line">        <span class="pl-c">// compute the area of the rectangle</span>
</span><span class="code-line">        <span class="pl-k">return</span> width*height;
</span><span class="code-line">    }
</span><span class="code-line">
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">class</span> <span class="pl-en">Circle</span> : <span class="pl-k">public</span> <span class="pl-en">Shape</span> {
</span><span class="code-line"><span class="pl-k">public:</span>
</span><span class="code-line">    <span class="pl-k">double</span> radius;
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-en">Circle</span>(<span class="pl-k">double</span> _radius): radius{ _radius } {}
</span><span class="code-line">    <span class="pl-en">~Circle</span>() <span class="pl-k">override</span> = <span class="pl-k">default</span>;
</span><span class="code-line">
</span><span class="code-line">    <span class="pl-k">auto</span> <span class="pl-en">render</span>(<span class="pl-k">const</span> Canvas&amp; canvas)-&gt;void <span class="pl-k">override</span> {
</span><span class="code-line">        <span class="pl-c">// render the circle to the canvas</span>
</span><span class="code-line">    }
</span><span class="code-line">    <span class="pl-k">auto</span> <span class="pl-en">area</span>()-&gt;double <span class="pl-k">override</span> {
</span><span class="code-line">        <span class="pl-c">// compute the area of the circle</span>
</span><span class="code-line">        <span class="pl-k">return</span> <span class="pl-c1">3.14</span>*radius*radius;
</span><span class="code-line">    }
</span><span class="code-line">}
</span></code></pre>
<p>You might prefer this design over function type proxies because it maps more directly onto object-oriented design patterns you&#x27;re already familiar with from Java (or other languages).
But it is also more verbose, and it has some other disadvantages.
Chief among them: any type with at least one virtual function no longer has a standard memory layout, meaning objects of such types cannot be <code>memcpy</code>-ed.
This is also the reason why we had to explicitly define the constructors for <code>Rectangle</code> and <code>Circle</code> above: aggregate initialization (i.e. <code>Rectangle{ .width = 2, .height = 3 }</code>) is not allowed for types with virtual functions.
The most important consequence of this propery is that such types cannot be allocated on the stack: every object of such a type must be dynamically allocated and accessed through a pointer.
You must then use smart pointers or manually manage the lifetime of each object very carefully to ensure that your code has no memory leaks.</p>
<h2 id="pointers-and-references-reprise"><a href="#pointers-and-references-reprise">Pointers and References (Reprise)</a></h2>
<p>In lab 1, we mentioned that we can access the entity that a pointer points to by dereferencing the pointer, and that a reference represents an entity at a particular memory address.
Pointers and references are so similar that it seems like there should be a connection between them.
And there is: when we dereference a pointer, what we get back is actually a reference:</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> x = <span class="pl-c1">42</span>;
</span><span class="code-line"><span class="pl-k">auto</span> px = &amp;x;
</span><span class="code-line">
</span><span class="code-line"><span class="pl-c">// we can verify that dereferencing a pointer indeed gives us a reference</span>
</span><span class="code-line"><span class="pl-en">static_assert</span>(std::same_as&lt;decltype(*px), int&amp;&gt;);
</span></code></pre>
<p>This is precisely the reason why dereferencing a pointer allows us to modify the object it points to, the same way as how we modify something via a reference.</p>
<p>One problem with the basic form of references we&#x27;ve learned so far is that they cannot bind to <em>values</em> (<a href="https://en.cppreference.com/w/cpp/language/value_category#rvalue" target="_blank" rel="noopener noreferrer">rvalue</a> in C++ terminology). This is because values such as <code>123</code> or <code>3.14</code> do not have a memory address because they are not stored in memory by some variable. The same applies to function parameters: we cannot pass values to reference parameters.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">func</span>(<span class="pl-k">int</span>&amp; n)-&gt;void {
</span><span class="code-line">    <span class="pl-c">// empty</span>
</span><span class="code-line">}
</span><span class="code-line"><span class="pl-k">auto</span> x = <span class="pl-c1">42</span>;
</span><span class="code-line"><span class="pl-k">auto</span>&amp; refx = x; <span class="pl-c">// OK, bind to a variable</span>
</span><span class="code-line"><span class="pl-k">auto</span>&amp; incorrectRefx = <span class="pl-c1">42</span>; <span class="pl-c">// error, (lvalue) reference cannot bind to (r)value</span>
</span><span class="code-line">
</span><span class="code-line"><span class="pl-en">func</span>(x); <span class="pl-c">// OK, reference parameter binds to &#x27;x&#x27;</span>
</span><span class="code-line"><span class="pl-en">func</span>(<span class="pl-c1">42</span>); <span class="pl-c">// error, (lvalue) reference parameter cannot bind to (r)value</span>
</span></code></pre>
<p>This can be inconvenient in some cases. Ideally, we&#x27;d want something that behaves like a reference when we bind it to a variable, and like a new variable when we provide it a value. Luckily, we do have something exactly like this in C++ called <em>forwarding</em> <em>references</em> in the form of <code>auto&amp;&amp;</code>.</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> <span class="pl-en">betterFunc</span>(<span class="pl-k">auto</span>&amp;&amp; n)-&gt;void {
</span><span class="code-line">  <span class="pl-c">// empty</span>
</span><span class="code-line">}
</span><span class="code-line">
</span><span class="code-line"><span class="pl-k">auto</span> x = <span class="pl-c1">42</span>;
</span><span class="code-line"><span class="pl-k">auto</span>&amp;&amp; refx = x; <span class="pl-c">// OK, bind to a variable, same as &#x27;auto&amp; refx = x;&#x27;</span>
</span><span class="code-line"><span class="pl-k">auto</span>&amp;&amp; forwardRef = <span class="pl-c1">42</span>; <span class="pl-c">// OK, creates a new variable as if &#x27;auto forwardRef = 42;&#x27;</span>
</span><span class="code-line">
</span><span class="code-line"><span class="pl-en">betterFunc</span>(x); <span class="pl-c">// OK, reference parameter binds to &#x27;x&#x27;</span>
</span><span class="code-line"><span class="pl-en">betterFunc</span>(<span class="pl-c1">42</span>); <span class="pl-c">// OK, as if the parameter type is non-reference</span>
</span></code></pre>
<details><summary>Be careful, though:</summary><p><code>&amp;&amp;</code> after a concrete type, like <code>int&amp;&amp;</code> or <code>std::vector&lt;int&gt;&amp;&amp;</code>, does not form a forwarding reference! These are <em>rvalue references</em> which are outside the scope of this doc. You can learn more about rvalue references <a href="https://en.cppreference.com/w/cpp/language/reference#Rvalue_references" target="_blank" rel="noopener noreferrer">here</a>, if you&#x27;re interested.</p></details>
<h2 id="pointer-arithmetic"><a href="#pointer-arithmetic">Pointer Arithmetic</a></h2>
<p>We&#x27;ve discussed in lab 1 that a pointer is an integer storing a memory address. What will happen though, if we perform integer arithmetics on pointers? Consider the following example</p>
<pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">auto</span> p = <span class="pl-k">reinterpret_cast</span>&lt;<span class="pl-k">int</span>*&gt;(<span class="pl-c1">42</span>); <span class="pl-c">// cast some random integer to a pointer</span>
</span><span class="code-line">p += <span class="pl-c1">1</span>;
</span><span class="code-line"><span class="pl-k">auto</span> x = <span class="pl-k">reinterpret_cast</span>&lt;<span class="pl-k">unsigned</span> <span class="pl-k">long</span> <span class="pl-k">long</span>&gt;(p); <span class="pl-c">// cast pointer back to integer</span>
</span><span class="code-line">std::cout &lt;&lt; x; <span class="pl-c">// what will you see here?</span>
</span></code></pre>
<p>You would probably think <code>x</code> is <code>43</code>. However depending on your hardware platform, you&#x27;re likely to see <code>46</code>! Why is that?</p>
<p>If you have a pointer <code>p</code> pointing to the address of some object of type <code>T</code>, <code>p + n</code> assumes that there is an array of <code>T</code>s stored in contiguous memory, and <code>p + n</code> evaluates to the address of the <code>n</code>-th object after the object that <code>p</code> points to. In the above example, <code>x</code> contains the address of a (hypothetical) integer next to the (hypothetical) integer whose address is <code>42</code>. Thus, the value of <code>x</code> would be <code>42 + sizeof(int)</code>; since <code>sizeof(int)</code> is <code>4</code> on most common hardware platforms (i.e. an integer is 4 bytes, or 32 bits), you see <code>46</code> when you print out <code>x</code>.</p>
<p>You can also <em>subtract</em> integers from pointers. For example, <code>p - m</code> gives the address of the <code>m</code>-th object before <code>*p</code>.</p>
<p>Pointer arithmetic is pretty common in C/C++, and since <code>*(p + n)</code> is unwieldy to type, the language defines a syntactic sugar for us to do the exact same thing: the indexing operator <code>p[n]</code> is equivalent to <code>*(p + n)</code>.</p>
<details><summary>Secrets behind C-style arrays</summary><p>If you have prior experience in C, you may be wondering why  our code examples typically use <code>std::array&lt;T, N&gt;</code> instead of the classic C-style array <code>T[N]</code>. We made this hoice because C-style arrays have some &quot;gotchas&quot; that can be confusing to beginners. Consider the following example:</p><pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line"><span class="pl-k">int</span> x1[<span class="pl-c1">3</span>]; <span class="pl-c">// Declare a C-style array</span>
</span><span class="code-line"><span class="pl-k">auto</span> x2 = std::array&lt;<span class="pl-k">int</span>, <span class="pl-c1">3</span>&gt;{}; <span class="pl-c">// Declare a C++ std::array</span>
</span><span class="code-line"><span class="pl-k">auto</span> y1 = x1; <span class="pl-c">// this is a pointer! not a copy of the &#x27;x1&#x27; array!</span>
</span><span class="code-line"><span class="pl-k">auto</span> y2 = x2; <span class="pl-c">// this is a copy of the &#x27;x2&#x27; array</span>
</span><span class="code-line">y1[<span class="pl-c1">0</span>] = <span class="pl-c1">42</span>; <span class="pl-c">// this is the same as &#x27;x1[0] = 42&#x27;</span>
</span><span class="code-line">y2[<span class="pl-c1">0</span>] = <span class="pl-c1">42</span>; <span class="pl-c">// this does nothing to x2, since it&#x27;s a copy</span>
</span></code></pre><p>The reason for this behavior is that C arrays automatically decay to (i.e. are converted to) the pointer to their first element.
When the compiler sees <code>x1[0]</code>, <code>x1</code> first decays to a pointer automatically, then the pointer indexing operator is invoked and then desugar-ed into <code>*(x1 + 0)</code>. Pointer arithmetic happens behind the scenes every time you manipulate a C-style array!</p></details>
<hr class="footer-hr"/><p class="footer-p">Please let us know if you find any mistakes, inconsistencies, or confusing language in this or any other CS 1230 document by filling out our <a href="https://forms.gle/ZYY519pzSvu8YaZK6" target="_blank">anonymous feedback form</a>.</p></main></div>
        </div>
      <script id="vite-plugin-ssr_pageContext" type="application/json">{"pageContext":{"_pageId":"/pages/docs/advanced-cpp-tutorial"}}</script><script type="module" src="/website-fall-23/assets/entry-client-routing.0fb0364c.js" async></script><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/pages/docs/advanced-cpp-tutorial.page.edec0e77.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/chunk-14d409af.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/chunk-b66c7dfa.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/renderer/_default.page.client.9e6448c1.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/entry-client-routing.0fb0364c.js"><link rel="modulepreload" as="script" type="text/javascript" href="/website-fall-23/assets/chunk-7f137163.js"></body>
    </html>