import{j as e}from"../../chunk-14d409af.js";import{M as r}from"../../chunk-b66c7dfa.js";const o={title:"Going Deeper with C++"};function n(a){const s=Object.assign({nav:"nav",ol:"ol",li:"li",a:"a",main:"main",h1:"h1",p:"p",em:"em",h2:"h2",pre:"pre",code:"code",span:"span",h3:"h3",strong:"strong"},a.components);return e.exports.jsxs(e.exports.Fragment,{children:[e.exports.jsx(s.nav,{className:"toc",children:e.exports.jsx(s.ol,{className:"toc-level toc-level-1",children:e.exports.jsxs(s.li,{className:"toc-item toc-item-h1",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h1",href:"#going-deeper-with-c",children:"Going Deeper with C++"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-2",children:[e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#dynamic-memory-allocation",children:"Dynamic Memory Allocation"}),e.exports.jsx(s.ol,{className:"toc-level toc-level-3",children:e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#smart-pointers",children:"Smart Pointers"})})})]}),e.exports.jsx(s.li,{className:"toc-item toc-item-h2",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#operator-overloading",children:"Operator Overloading"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h2",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#lambda-expressions",children:"Lambda Expressions"})}),e.exports.jsxs(s.li,{className:"toc-item toc-item-h2",children:[e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#runtime-polymorphism",children:"Runtime Polymorphism"}),e.exports.jsxs(s.ol,{className:"toc-level toc-level-3",children:[e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#function-type-proxies",children:"Function Type Proxies"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h3",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h3",href:"#virtual-functions",children:"Virtual Functions"})})]})]}),e.exports.jsx(s.li,{className:"toc-item toc-item-h2",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#pointers-and-references-reprise",children:"Pointers and References (Reprise)"})}),e.exports.jsx(s.li,{className:"toc-item toc-item-h2",children:e.exports.jsx(s.a,{className:"toc-link toc-link-h2",href:"#pointer-arithmetic",children:"Pointer Arithmetic"})})]})]})})}),e.exports.jsxs(s.main,{children:[`
`,`
`,e.exports.jsx(s.h1,{id:"going-deeper-with-c",children:e.exports.jsx(s.a,{href:"#going-deeper-with-c",children:"Going Deeper with C++"})}),`
`,e.exports.jsxs(s.p,{children:[`In lab 1, we introduced you to the minimum C++ features you'll need for programming work in this course.
In this document, we cover additional C++ features you can use to improve your program design.
We'll also talk a bit about things happening "under the hood" for you to have a deeper understanding of how the language works. C++ is a huge, featureful language, so we're not attempting to cover `,e.exports.jsx(s.em,{children:"everything"})," that's possible within the language. Rather, we've picked a handful of topics that we think may be most useful for the work you do in this course."]}),`
`,e.exports.jsx(s.h2,{id:"dynamic-memory-allocation",children:e.exports.jsx(s.a,{href:"#dynamic-memory-allocation",children:"Dynamic Memory Allocation"})}),`
`,e.exports.jsx(s.p,{children:"Consider the following code:"}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Person"}),` {
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    std::string name;
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"unsigned"})," ",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),` age;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`};
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"void"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"doStuff"}),`() {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    Person arvind = { .",e.exports.jsx(s.span,{className:"pl-smi",children:"name"})," = ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"Arvind",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]}),", .",e.exports.jsx(s.span,{className:"pl-smi",children:"age"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"20"}),` };
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    Person maya = { .",e.exports.jsx(s.span,{className:"pl-smi",children:"name"})," = ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"Maya",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]}),", .",e.exports.jsx(s.span,{className:"pl-smi",children:"age"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"21"}),` };
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// ..."}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsxs(s.p,{children:["In this example, the compiler knows how big a ",e.exports.jsx(s.code,{children:"Person"})," object is (i.e. how much memory it takes up), so it allocates enough memory on the stack to store these two ",e.exports.jsx(s.code,{children:"Person"})," objects."]}),`
`,e.exports.jsxs(s.p,{children:["But what if we don't know how many ",e.exports.jsx(s.code,{children:"Person"})," objects we'll need to create at compile time? For example, imagine the scenario where we need to load a list of people from a file on disk. The standard way to handle this situation would be to put the ",e.exports.jsx(s.code,{children:"Person"})," objects in an ",e.exports.jsx(s.code,{children:"std::vector"}),":"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"void"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"doStuff"}),`() {
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    std::vector<Person> people;
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c1",children:"loadFromFile"}),"(",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"people.txt",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]}),`, people);
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// ..."}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsxs(s.p,{children:["But how is ",e.exports.jsx(s.code,{children:"std::vector"})," actually implemented? It can't possibly be storing its objects on the stack, because the compiler doesn't know in advance how much stack space to allocate. Internally, ",e.exports.jsx(s.code,{children:"std::vector"})," is ",e.exports.jsx(s.em,{children:"dynamically allocating"})," memory on the heap to store these objects. In C++, you can dynamically allocate memory using the ",e.exports.jsx(s.code,{children:"new"})," operator. Here's how we would rewrite the above example to use ",e.exports.jsx(s.code,{children:"new"})," directly, instead of relying on ",e.exports.jsx(s.code,{children:"std::vector"}),":"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"void"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"doStuff"}),`() {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// Allocate enough memory on the heap to store all the people in the text file"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"int"})," numPeople = ",e.exports.jsx(s.span,{className:"pl-c1",children:"numberOfLines"}),"(",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"people.txt",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]}),`);
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," people = ",e.exports.jsx(s.span,{className:"pl-k",children:"new"}),` Person[numPeople];
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c1",children:"loadFromFile"}),"(",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"people.txt",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]}),`, people);
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// ..."}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"delete[]"}),` people;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsxs(s.p,{children:["The syntax ",e.exports.jsx(s.code,{children:"new Person[numPeople]"}),' means "allocate a continguous block of memory on the heap that can store ',e.exports.jsx(s.code,{children:"numPeople"})," instances of the ",e.exports.jsx(s.code,{children:"Person"}),` object."
If you only wanted to allocate a single `,e.exports.jsx(s.code,{children:"Person"})," object, the syntax looks a little simpler:"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"void"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"doStuff"}),`() {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," person = ",e.exports.jsx(s.span,{className:"pl-k",children:"new"})," Person{ .",e.exports.jsx(s.span,{className:"pl-smi",children:"name"})," = ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"Arvind",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]}),", .",e.exports.jsx(s.span,{className:"pl-smi",children:"age"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"20"}),` };
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// ..."}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"delete"}),` person;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsxs(s.p,{children:["Note, in both cases, the presence of the ",e.exports.jsx(s.code,{children:"delete"})," operator at the end of the code. This is necessary because the compiler doesn't know when you're done using the memory you've allocated on the heap. If you don't explicitly ",e.exports.jsx(s.code,{children:"delete"})," the memory you've allocated, it will stay allocated until the program exits, a situation known as a ",e.exports.jsx(s.em,{children:"memory leak"}),". Memory leaks are bad: in the worst case, they can cause your program to run out of memory and crash. In the best case, your program uses more memory than it needs to, which can cause performance problems (slowing down your computer; wasting battery life on laptops and mobile devices)."]}),`
`,e.exports.jsxs(s.p,{children:["Managing dynamically-allocated memory manually with ",e.exports.jsx(s.code,{children:"new"})," and ",e.exports.jsx(s.code,{children:"delete"})," can be tricky, because you have to remember to ",e.exports.jsx(s.code,{children:"delete"})," every object you ",e.exports.jsx(s.code,{children:"new"}),"-ed, and you have to make sure you don't ",e.exports.jsx(s.code,{children:"delete"})," an object more than once. If you forget to ",e.exports.jsx(s.code,{children:"delete"})," an object, you have a memory leak. If you ",e.exports.jsx(s.code,{children:"delete"})," an object more than once, you have a ",e.exports.jsx(s.em,{children:"double free"})," error: your program can crash when it tries to access memory that's no longer allocated to it. These bugs can be so gnarly that we decided not even to teach you how to use ",e.exports.jsx(s.code,{children:"new"})," and ",e.exports.jsx(s.code,{children:"delete"})," in lab 1. Instead, we taught you how to use ",e.exports.jsx(s.code,{children:"std::vector"}),", which manages memory for you automatically. You can absolutely get by using ",e.exports.jsx(s.code,{children:"std::vector"}),` for all your dynamic memory needs in this course, if you like.
There are reasons you might want to dynamically allocate memory yourself, though (like the `,e.exports.jsx(s.a,{href:"#virtual-functions",children:"virtual function-based runtime polymorphism"})," that we discuss later in this document)."]}),`
`,e.exports.jsx(s.h3,{id:"smart-pointers",children:e.exports.jsx(s.a,{href:"#smart-pointers",children:"Smart Pointers"})}),`
`,e.exports.jsxs(s.p,{children:["The C++ standard library has some features that make it easier to manage dynamic memory. In particular, it provides ",e.exports.jsx(s.em,{children:"smart pointers"}),": objects that behave like pointers, but automatically manage the memory they point to. For example:"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"void"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"doStuff"}),`() {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),` person = std::unique_ptr<Person>{
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-k",children:"new"})," Person{ .",e.exports.jsx(s.span,{className:"pl-smi",children:"name"})," = ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"Arvind",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]}),", .",e.exports.jsx(s.span,{className:"pl-smi",children:"age"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"20"}),` }
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    };
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// ..."}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// No need to explicitly delete the person object;"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// it will be deleted automatically when the unique_ptr goes out of scope."}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsxs(s.p,{children:[e.exports.jsx(s.code,{children:"unique_ptr"})," is so named because you can have only one ",e.exports.jsx(s.code,{children:"unique_ptr"})," referring to a particular object at a time. If you try to copy a ",e.exports.jsx(s.code,{children:"unique_ptr"}),", the compiler will give you an error:"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"void"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"doStuff"}),`() {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),` person = std::unique_ptr<Person>{
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-k",children:"new"})," Person{ .",e.exports.jsx(s.span,{className:"pl-smi",children:"name"})," = ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"Arvind",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]}),", .",e.exports.jsx(s.span,{className:"pl-smi",children:"age"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"20"}),` }
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    };
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// ..."}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," person2 = person; ",e.exports.jsx(s.span,{className:"pl-c",children:"// error: cannot copy a unique_ptr"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsxs(s.p,{children:["If you have a situation where you need multiple variables referring to the same dynamic object, the standard library provides another smart pointer type, ",e.exports.jsx(s.code,{children:"shared_ptr"}),", which allows this. There is also a third smart pointer type, ",e.exports.jsx(s.code,{children:"weak_ptr"}),", which is sometimes necessary to use in conjuction with ",e.exports.jsx(s.code,{children:"shared_ptr"}),". We won't talk about ",e.exports.jsx(s.code,{children:"shared_ptr"})," and ",e.exports.jsx(s.code,{children:"weak_ptr"})," in this document, but you can read more about them ",e.exports.jsx(s.a,{href:"https://en.cppreference.com/w/cpp/memory/shared_ptr",target:"_blank",rel:"noopener noreferrer",children:"here"})," and ",e.exports.jsx(s.a,{href:"https://en.cppreference.com/w/cpp/memory/weak_ptr",target:"_blank",rel:"noopener noreferrer",children:"here"}),", if you're interested."]}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"For those interested in programming language implementation:"}),e.exports.jsxs(s.p,{children:[e.exports.jsx(s.code,{children:"shared_ptr"})," implements a form of ",e.exports.jsx(s.a,{href:"https://en.wikipedia.org/wiki/Reference_counting",target:"_blank",rel:"noopener noreferrer",children:"reference counting"}),", which is a type of automatic memory management algorithm used by some programming languages that do not allow manual memory management (e.g. Python). Such automatic memory management algorithms are also known as ",e.exports.jsx(s.a,{href:"https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)",target:"_blank",rel:"noopener noreferrer",children:"garbage collection"})," algorithms."]})]}),`
`,e.exports.jsx(s.h2,{id:"operator-overloading",children:e.exports.jsx(s.a,{href:"#operator-overloading",children:"Operator Overloading"})}),`
`,e.exports.jsxs(s.p,{children:["Object-oriented programming is great, but writing out long method names when calling functions on objects can be tedious. For example, if have a ",e.exports.jsx(s.code,{children:"vec3"})," class representing a 3D vector, and I want to add three vectors together, it's both tedious to type and hard to read if I have to write the code like this:"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," v1 = vec3{ ",e.exports.jsx(s.span,{className:"pl-c1",children:"1.1"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"4.2"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"2.5"}),` };
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," v2 = vec3{ ",e.exports.jsx(s.span,{className:"pl-c1",children:"0.4"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"2.6"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"3.1"}),` };
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," v3 = vec3{ ",e.exports.jsx(s.span,{className:"pl-c1",children:"2.3"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"1.2"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"0.5"}),` };
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),` v4 = v1.add(v2).add(v3);
`]})]})}),`
`,e.exports.jsxs(s.p,{children:["Wouldn't it be nice if we could just write ",e.exports.jsx(s.code,{children:"v1 + v2 + v3"})," instead? We can, using a feature of C++ called ",e.exports.jsx(s.em,{children:"operator overloading"}),":"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"vec3"}),` {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"double"}),` x;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"double"}),` y;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"double"}),` z;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    vec3 ",e.exports.jsx(s.span,{className:"pl-k",children:"operator"}),"+(",e.exports.jsx(s.span,{className:"pl-k",children:"const"}),` vec3& other) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-k",children:"return"}),` vec3{
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["            .",e.exports.jsx(s.span,{className:"pl-smi",children:"x"})," = x + other.",e.exports.jsx(s.span,{className:"pl-smi",children:"x"}),`,
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["            .",e.exports.jsx(s.span,{className:"pl-smi",children:"y"})," = y + other.",e.exports.jsx(s.span,{className:"pl-smi",children:"y"}),`,
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["            .",e.exports.jsx(s.span,{className:"pl-smi",children:"z"})," = z + other.",e.exports.jsx(s.span,{className:"pl-smi",children:"z"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`        };
`}),e.exports.jsx(s.span,{className:"code-line",children:`    }
`}),e.exports.jsx(s.span,{className:"code-line",children:`};
`})]})}),`
`,e.exports.jsxs(s.p,{children:["There are ",e.exports.jsx(s.em,{children:"tons"})," of operators that you can overload in C++: the assignment operator ",e.exports.jsx(s.code,{children:"="}),"; the array subscript operator ",e.exports.jsx(s.code,{children:"[]"}),'; even the "deference pointer to object and call method" operator ',e.exports.jsx(s.code,{children:"->"})," (which is how smart pointers are implemented, by the way). You can find a list of them ",e.exports.jsx(s.a,{href:"https://en.cppreference.com/w/cpp/language/operators",target:"_blank",rel:"noopener noreferrer",children:"here"}),"."]}),`
`,e.exports.jsx(s.h2,{id:"lambda-expressions",children:e.exports.jsx(s.a,{href:"#lambda-expressions",children:"Lambda Expressions"})}),`
`,e.exports.jsxs(s.p,{children:[`Lambda expressions are one of the most important constructs in modern C++. It is what makes functional programming possible in the language, and it can be handy even for non-functional designs.
In other languages, lambdas are also known as `,e.exports.jsx(s.em,{children:"anonymous functions"})," or ",e.exports.jsx(s.em,{children:"closures"}),`.
They can appear almost anywhere in your program: unlike regular functions, which may `,e.exports.jsx(s.strong,{children:"not"})," appear inside other functions, lambdas can appear in any scope just like other primitives of the language such as an ",e.exports.jsx(s.code,{children:"int"})," or a ",e.exports.jsx(s.code,{children:"float"}),". You may assign lambdas to variables and pass them around as parameters or return values. The lambda syntax looks very similar to functions, with the addition of a ",e.exports.jsx(s.strong,{children:"capture list"}),":"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// Lambda syntax: [capture list](parameter list) { function body }"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// the parameter list can be omitted if the lambda takes no arguments."}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," identity = [](",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x) { ",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," x; }; ",e.exports.jsx(s.span,{className:"pl-c",children:'// Must use type "auto" for a variable to which a lambda expression is assigned.'}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x = identity(",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),"); ",e.exports.jsx(s.span,{className:"pl-c",children:"// x = 42"}),`
`]})]})}),`
`,e.exports.jsxs(s.p,{children:["The capture list controls how the lambda accesses variables in its surrounding scope. An empty capture list indicates that the lambda has no access to its surrounding scope. If access to the surrounding scope is required, the lambda may capture all the variables in its scope by value (",e.exports.jsx(s.code,{children:"="}),") or by reference (",e.exports.jsx(s.code,{children:"&"}),"):"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," f = [=] { std::cout << x; }; ",e.exports.jsx(s.span,{className:"pl-c",children:"// captures x by value, this makes a copy of x in f."}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," g = [&] { ++x; }; ",e.exports.jsx(s.span,{className:"pl-c",children:"// captures x by reference, x in the outer scope will be affected when g is called."}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," h = [] { ",e.exports.jsx(s.span,{className:"pl-c",children:"/* cannot access x here */"})," }; ",e.exports.jsx(s.span,{className:"pl-c",children:"// captures nothing."}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-en",children:"f"}),"(); ",e.exports.jsx(s.span,{className:"pl-c",children:"// prints 42"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-en",children:"g"}),"(); ",e.exports.jsx(s.span,{className:"pl-c",children:"// now x = 43"}),`
`]})]})}),`
`,e.exports.jsxs(s.p,{children:["The capture list can also be more specific, if desired. Something like ",e.exports.jsx(s.code,{children:"[&, x]"})," means ",e.exports.jsx(s.code,{children:"x"})," is captured by value and everything else is captured by reference. ",e.exports.jsx(s.code,{children:"[=, &x]"})," on the other hand, means ",e.exports.jsx(s.code,{children:"x"})," is captured by reference and everything else is captured by value."]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," y = ",e.exports.jsx(s.span,{className:"pl-c1",children:"2.71"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," z = ",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"aaa",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]}),`;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," f = [&, x]() ",e.exports.jsx(s.span,{className:"pl-k",children:"mutable"})," { ++x; }; ",e.exports.jsx(s.span,{className:"pl-c",children:"// x captured by value, y and z captured by reference. The \u201Cmutable\u201D specifier is required if you need to modify something captured by value."}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," g = [=, &x] {}; ",e.exports.jsx(s.span,{className:"pl-c",children:"// x captured by reference, y and z captured by value."}),`
`]})]})}),`
`,e.exports.jsxs(s.p,{children:[`Determining the best way to capture can be tricky.
For example, capturing by reference incorrectly can lead to `,e.exports.jsx(s.em,{children:"dangling references"}),":"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"f"}),`() {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," [&] { ++x; }; ",e.exports.jsx(s.span,{className:"pl-c",children:"// dangling reference here: by the time that the lambda is returned, the local variable x that it references is already released."}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsx(s.p,{children:"As a rule of thumb, we recommend to capture by reference if the lambda is invoked within the scope where it\u2019s defined and to capture by value if the lambda outlives the current scope (e.g. if the lambda is returned from a function)."}),`
`,e.exports.jsxs(s.p,{children:[`Lambdas are useful for all sorts of things. Here's a common use case: defining a custom sorting function for a vector of objects.
For example, if we have a vector of `,e.exports.jsx(s.code,{children:"Person"})," objects, we might want to sort them by their age:"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Person"}),` {
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    std::string name;
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"unsigned"})," ",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),` age;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`};
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," people = std::vector<Person>{ ",e.exports.jsx(s.span,{className:"pl-c",children:"/* ... */"})," };  ",e.exports.jsx(s.span,{className:"pl-c",children:"// Populate list of people"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// Sort people by age"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// The sort function takes three arguments: the beginning and end of the range to sort, and a function that compares two elements."}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-en",children:"std::sort"}),`(people.begin(), people.end(),
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["[](",e.exports.jsx(s.span,{className:"pl-k",children:"const"})," Person& a, ",e.exports.jsx(s.span,{className:"pl-k",children:"const"}),` Person& b) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," a.",e.exports.jsx(s.span,{className:"pl-smi",children:"age"})," < b.",e.exports.jsx(s.span,{className:"pl-smi",children:"age"}),`;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`});
`})]})}),`
`,e.exports.jsx(s.h2,{id:"runtime-polymorphism",children:e.exports.jsx(s.a,{href:"#runtime-polymorphism",children:"Runtime Polymorphism"})}),`
`,e.exports.jsxs(s.p,{children:[e.exports.jsx(s.em,{children:"Polymorphism"}),` refers to the same code being able to operate on different data types.
Needing to do this is so common that any general-purpose programming language worth its salt will implement some form of polymorphism.
You already saw one form of polymorphism in lab 1: generic functions (i.e. functions with `,e.exports.jsx(s.code,{children:"auto"})," parameters, a.k.a function templates), which is known more broadly as ",e.exports.jsx(s.em,{children:"parametric polymorphism"}),`.
While this kind of polymorphism is useful, it has some limitations.
Each time you call a generic function, the compiler checks the types of the arguments you're passing to it and generates a new version of the function that's specialized to those types.
This means that those types must be known at compile time...and this isn't always the case.
Sometimes, you'll need to write code that can handle multiple types of objects, but those types are only known at runtime--this is known as `,e.exports.jsx(s.em,{children:"runtime polymorphism"}),`.
Consider the following example:`]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// Declare a vector which will hold some objects."}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),` objects = std::vector<??>{};
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// Load a list of object type ids from a file."}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["std::vector<",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),"> ids = loadFromFile(",e.exports.jsxs(s.span,{className:"pl-s",children:[e.exports.jsx(s.span,{className:"pl-pds",children:'"'}),"objectTypes.txt",e.exports.jsx(s.span,{className:"pl-pds",children:'"'})]}),`);
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// Populate 'objects' with objects of the correct type,"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// according to the ids loaded from the file."}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"for"})," (",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),` id : ids) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"switch"}),` (id) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-k",children:"case"})," ",e.exports.jsx(s.span,{className:"pl-c1",children:"0"}),": objects.",e.exports.jsx(s.span,{className:"pl-c1",children:"emplace_back"}),"(Rectangle{ .",e.exports.jsx(s.span,{className:"pl-smi",children:"width"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"2"}),", height = ",e.exports.jsx(s.span,{className:"pl-c1",children:"3"})," }); ",e.exports.jsx(s.span,{className:"pl-k",children:"break"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-k",children:"case"})," ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"}),": objects.",e.exports.jsx(s.span,{className:"pl-c1",children:"emplace_back"}),"(Circle{ .",e.exports.jsx(s.span,{className:"pl-smi",children:"radius"})," = ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"})," }); ",e.exports.jsx(s.span,{className:"pl-k",children:"break"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-c",children:"// ..."}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    }
`}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsxs(s.p,{children:["We need to be able to store multiple types of objects in the ",e.exports.jsx(s.code,{children:"objects"})," vector...so what type should we replace ",e.exports.jsx(s.code,{children:"??"}),` with?
Essentially, we need to create some kind of `,e.exports.jsx(s.em,{children:"proxy"})," type ",e.exports.jsx(s.code,{children:"T"})," that can represent any of the types we want to store in the vector. In the above example, ",e.exports.jsx(s.code,{children:"T"})," would be something like ",e.exports.jsx(s.code,{children:"Shape"}),"."]}),`
`,e.exports.jsxs(s.p,{children:["If you're familiar with Java, you've seen this design pattern before with Java's object-oriented programming features (in particular, the ",e.exports.jsx(s.code,{children:"interface"}),` construct).
C++, being the complex beast that it is, has multiple ways to achieve the same behavior. We'll talk about two of them here: function type proxies and virtual functions.
The latter is the "traditional" way of achieving runtime polymorphism in C++ code (older versions of this course taught it exclusively and used it in stencil code), but it has some downsides that can make it inconvenient to use (more on this later). Thus, we talk about function type proxies first, because they are more straightforward.`]}),`
`,e.exports.jsx(s.h3,{id:"function-type-proxies",children:e.exports.jsx(s.a,{href:"#function-type-proxies",children:"Function Type Proxies"})}),`
`,e.exports.jsxs(s.p,{children:["Suppose that the only thing we need to be able to do with our shape objects is render them to some ",e.exports.jsx(s.code,{children:"Canvas"})," object. Then we could use the ",e.exports.jsx(s.em,{children:"type signature of this render function"})," as our proxy type, and we'd define our shape types using lambdas:"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"using"})," RenderSignature = ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"const"})," Canvas&)->",e.exports.jsx(s.span,{className:"pl-k",children:"void"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"using"}),` Shape = std::function<RenderSignature>;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Rectangle"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),` width, height) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," [=](",e.exports.jsx(s.span,{className:"pl-k",children:"const"}),` Canvas& canvas) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-c",children:"// render the rectangle to the canvas"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    };
`}),e.exports.jsx(s.span,{className:"code-line",children:`}
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Circle"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),` radius) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," [=](",e.exports.jsx(s.span,{className:"pl-k",children:"const"}),` Canvas& canvas) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-c",children:"// render the circle to the canvas"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    };
`}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsxs(s.p,{children:["Since the lambdas returned by the ",e.exports.jsx(s.code,{children:"Rectangle"})," and ",e.exports.jsx(s.code,{children:"Circle"})," functions have the same type signature as ",e.exports.jsx(s.code,{children:"RenderSignature"}),", we can assign them to variables of type ",e.exports.jsx(s.code,{children:"Shape"})," and store them in a vector of ",e.exports.jsx(s.code,{children:"Shape"}),". Note that our use of the ",e.exports.jsx(s.code,{children:"="})," capture mode allows the returned lambdas to capture the arguments to the shape constructors (e.g. ",e.exports.jsx(s.code,{children:"width"}),", ",e.exports.jsx(s.code,{children:"height"}),") by value, so that they can be used later when the lambdas are called."]}),`
`,e.exports.jsxs(s.p,{children:["If each shape type has multiple functions that we need to be able to call, then we can package these functions into a ",e.exports.jsx(s.code,{children:"struct"})," and use the type of that ",e.exports.jsx(s.code,{children:"struct"}),` as our proxy type.
For example, let's say that we want to be able to render shapes and also compute their areas:`]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"using"})," RenderSignature = ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"const"})," Canvas&)->",e.exports.jsx(s.span,{className:"pl-k",children:"void"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"using"})," AreaSignature = ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"()->",e.exports.jsx(s.span,{className:"pl-k",children:"double"}),`;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"struct"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Shape"}),` {
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    std::function<RenderSignature> render;
`}),e.exports.jsx(s.span,{className:"code-line",children:`    std::function<AreaSignature> area;
`}),e.exports.jsx(s.span,{className:"code-line",children:`}
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Rectangle"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"int"})," width, ",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),` height) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"return"}),` Shape{
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        [=](",e.exports.jsx(s.span,{className:"pl-k",children:"const"}),` Canvas& canvas) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["            ",e.exports.jsx(s.span,{className:"pl-c",children:"// render the rectangle to the canvas"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`        },
`}),e.exports.jsx(s.span,{className:"code-line",children:`        [=]() {
`}),e.exports.jsxs(s.span,{className:"code-line",children:["            ",e.exports.jsx(s.span,{className:"pl-c",children:"// compute the area of the rectangle"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["            ",e.exports.jsx(s.span,{className:"pl-k",children:"return"}),` width*height;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`        }
`}),e.exports.jsx(s.span,{className:"code-line",children:`    };
`}),e.exports.jsx(s.span,{className:"code-line",children:`}
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Circle"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),` radius) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"return"}),` Shape{
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        [=](",e.exports.jsx(s.span,{className:"pl-k",children:"const"}),` Canvas& canvas) {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["            ",e.exports.jsx(s.span,{className:"pl-c",children:"// render the circle to the canvas"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`        },
`}),e.exports.jsx(s.span,{className:"code-line",children:`        [=]() {
`}),e.exports.jsxs(s.span,{className:"code-line",children:["            ",e.exports.jsx(s.span,{className:"pl-c",children:"// compute the area of the circle"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["            ",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," ",e.exports.jsx(s.span,{className:"pl-c1",children:"3.14"}),`*radius*radius;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`        }
`}),e.exports.jsx(s.span,{className:"code-line",children:`    };
`}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsx(s.h3,{id:"virtual-functions",children:e.exports.jsx(s.a,{href:"#virtual-functions",children:"Virtual Functions"})}),`
`,e.exports.jsxs(s.p,{children:[`Lambdas are a relatively new feature of C++: they were introduced in the C++11 standard (so named because it was released in 2011), but the C++ language has been around for a lot longer (since 1985).
Before lambdas, we couldn't pass functions around as data, so we couldn't use the function type proxy design pattern described above. Instead, we had to use a different design pattern: `,e.exports.jsx(s.em,{children:"virtual functions"}),"."]}),`
`,e.exports.jsxs(s.p,{children:[`Virtual functions are one of C++'s built-in object-oriented programming features.
A virtual function is a function defined in a struct/class whose behavior can be overridden by child structs/classes.
Here is the same `,e.exports.jsx(s.code,{children:"Shape"})," example from above, rewritten to use virtual functions:"]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"class"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Shape"}),` {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"public:"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:'// The "= 0;" at the end of a function declaration means that'}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:'//   the function is "pure virtual", i.e. it has no implementation in this base class.'}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:`// This is similar to Java's "abstract" keyword for methods.`}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"virtual"})," ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"render"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"const"}),` Canvas& canvas)->void = 0;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"virtual"})," ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"area"}),`()->double = 0;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// A class with virtual functions must declare a virtual destructor"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"virtual"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"~Shape"}),"() = ",e.exports.jsx(s.span,{className:"pl-k",children:"default"}),`;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:'// ": public Shape" means that Rectangle inherits from Shape'}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"class"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Rectangle"})," : ",e.exports.jsx(s.span,{className:"pl-k",children:"public"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Shape"}),` {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"public:"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"double"}),` width;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"double"}),` height;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// Why are we explicitly defining such a simple constructor here?"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// Why not just use aggregate initialization?"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// More on this later..."}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-en",children:"Rectangle"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"double"})," _width, ",e.exports.jsx(s.span,{className:"pl-k",children:"double"}),` _height): width{ _width }, height{ _height } {}
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// Override the virtual destructor from the base class"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-en",children:"~Rectangle"}),"() ",e.exports.jsx(s.span,{className:"pl-k",children:"override"})," = ",e.exports.jsx(s.span,{className:"pl-k",children:"default"}),`;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"render"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"const"})," Canvas& canvas)->void ",e.exports.jsx(s.span,{className:"pl-k",children:"override"}),` {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-c",children:"// render the rectangle to the canvas"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    }
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"area"}),"()->double ",e.exports.jsx(s.span,{className:"pl-k",children:"override"}),` {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-c",children:"// compute the area of the rectangle"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-k",children:"return"}),` width*height;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    }
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsx(s.span,{className:"code-line",children:`}
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"class"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Circle"})," : ",e.exports.jsx(s.span,{className:"pl-k",children:"public"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"Shape"}),` {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"public:"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"double"}),` radius;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-en",children:"Circle"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"double"}),` _radius): radius{ _radius } {}
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-en",children:"~Circle"}),"() ",e.exports.jsx(s.span,{className:"pl-k",children:"override"})," = ",e.exports.jsx(s.span,{className:"pl-k",children:"default"}),`;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"render"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"const"})," Canvas& canvas)->void ",e.exports.jsx(s.span,{className:"pl-k",children:"override"}),` {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-c",children:"// render the circle to the canvas"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    }
`}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"area"}),"()->double ",e.exports.jsx(s.span,{className:"pl-k",children:"override"}),` {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-c",children:"// compute the area of the circle"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["        ",e.exports.jsx(s.span,{className:"pl-k",children:"return"})," ",e.exports.jsx(s.span,{className:"pl-c1",children:"3.14"}),`*radius*radius;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`    }
`}),e.exports.jsx(s.span,{className:"code-line",children:`}
`})]})}),`
`,e.exports.jsxs(s.p,{children:[`You might prefer this design over function type proxies because it maps more directly onto object-oriented design patterns you're already familiar with from Java (or other languages).
But it is also more verbose, and it has some other disadvantages.
Chief among them: any type with at least one virtual function no longer has a standard memory layout, meaning objects of such types cannot be `,e.exports.jsx(s.code,{children:"memcpy"}),`-ed.
This is also the reason why we had to explicitly define the constructors for `,e.exports.jsx(s.code,{children:"Rectangle"})," and ",e.exports.jsx(s.code,{children:"Circle"})," above: aggregate initialization (i.e. ",e.exports.jsx(s.code,{children:"Rectangle{ .width = 2, .height = 3 }"}),`) is not allowed for types with virtual functions.
The most important consequence of this propery is that such types cannot be allocated on the stack: every object of such a type must be dynamically allocated and accessed through a pointer.
You must then use smart pointers or manually manage the lifetime of each object very carefully to ensure that your code has no memory leaks.`]}),`
`,e.exports.jsx(s.h2,{id:"pointers-and-references-reprise",children:e.exports.jsx(s.a,{href:"#pointers-and-references-reprise",children:"Pointers and References (Reprise)"})}),`
`,e.exports.jsx(s.p,{children:`In lab 1, we mentioned that we can access the entity that a pointer points to by dereferencing the pointer, and that a reference represents an entity at a particular memory address.
Pointers and references are so similar that it seems like there should be a connection between them.
And there is: when we dereference a pointer, what we get back is actually a reference:`}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),` px = &x;
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-c",children:"// we can verify that dereferencing a pointer indeed gives us a reference"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-en",children:"static_assert"}),`(std::same_as<decltype(*px), int&>);
`]})]})}),`
`,e.exports.jsx(s.p,{children:"This is precisely the reason why dereferencing a pointer allows us to modify the object it points to, the same way as how we modify something via a reference."}),`
`,e.exports.jsxs(s.p,{children:["One problem with the basic form of references we've learned so far is that they cannot bind to ",e.exports.jsx(s.em,{children:"values"})," (",e.exports.jsx(s.a,{href:"https://en.cppreference.com/w/cpp/language/value_category#rvalue",target:"_blank",rel:"noopener noreferrer",children:"rvalue"})," in C++ terminology). This is because values such as ",e.exports.jsx(s.code,{children:"123"})," or ",e.exports.jsx(s.code,{children:"3.14"})," do not have a memory address because they are not stored in memory by some variable. The same applies to function parameters: we cannot pass values to reference parameters."]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"func"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),`& n)->void {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["    ",e.exports.jsx(s.span,{className:"pl-c",children:"// empty"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"& refx = x; ",e.exports.jsx(s.span,{className:"pl-c",children:"// OK, bind to a variable"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"& incorrectRefx = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),"; ",e.exports.jsx(s.span,{className:"pl-c",children:"// error, (lvalue) reference cannot bind to (r)value"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-en",children:"func"}),"(x); ",e.exports.jsx(s.span,{className:"pl-c",children:"// OK, reference parameter binds to 'x'"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-en",children:"func"}),"(",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),"); ",e.exports.jsx(s.span,{className:"pl-c",children:"// error, (lvalue) reference parameter cannot bind to (r)value"}),`
`]})]})}),`
`,e.exports.jsxs(s.p,{children:["This can be inconvenient in some cases. Ideally, we'd want something that behaves like a reference when we bind it to a variable, and like a new variable when we provide it a value. Luckily, we do have something exactly like this in C++ called ",e.exports.jsx(s.em,{children:"forwarding"})," ",e.exports.jsx(s.em,{children:"references"})," in the form of ",e.exports.jsx(s.code,{children:"auto&&"}),"."]}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," ",e.exports.jsx(s.span,{className:"pl-en",children:"betterFunc"}),"(",e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),`&& n)->void {
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["  ",e.exports.jsx(s.span,{className:"pl-c",children:"// empty"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`}
`}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& refx = x; ",e.exports.jsx(s.span,{className:"pl-c",children:"// OK, bind to a variable, same as 'auto& refx = x;'"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"}),"&& forwardRef = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),"; ",e.exports.jsx(s.span,{className:"pl-c",children:"// OK, creates a new variable as if 'auto forwardRef = 42;'"}),`
`]}),e.exports.jsx(s.span,{className:"code-line",children:`
`}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-en",children:"betterFunc"}),"(x); ",e.exports.jsx(s.span,{className:"pl-c",children:"// OK, reference parameter binds to 'x'"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-en",children:"betterFunc"}),"(",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),"); ",e.exports.jsx(s.span,{className:"pl-c",children:"// OK, as if the parameter type is non-reference"}),`
`]})]})}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"Be careful, though:"}),e.exports.jsxs(s.p,{children:[e.exports.jsx(s.code,{children:"&&"})," after a concrete type, like ",e.exports.jsx(s.code,{children:"int&&"})," or ",e.exports.jsx(s.code,{children:"std::vector<int>&&"}),", does not form a forwarding reference! These are ",e.exports.jsx(s.em,{children:"rvalue references"})," which are outside the scope of this doc. You can learn more about rvalue references ",e.exports.jsx(s.a,{href:"https://en.cppreference.com/w/cpp/language/reference#Rvalue_references",target:"_blank",rel:"noopener noreferrer",children:"here"}),", if you're interested."]})]}),`
`,e.exports.jsx(s.h2,{id:"pointer-arithmetic",children:e.exports.jsx(s.a,{href:"#pointer-arithmetic",children:"Pointer Arithmetic"})}),`
`,e.exports.jsx(s.p,{children:"We've discussed in lab 1 that a pointer is an integer storing a memory address. What will happen though, if we perform integer arithmetics on pointers? Consider the following example"}),`
`,e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," p = ",e.exports.jsx(s.span,{className:"pl-k",children:"reinterpret_cast"}),"<",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),"*>(",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),"); ",e.exports.jsx(s.span,{className:"pl-c",children:"// cast some random integer to a pointer"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["p += ",e.exports.jsx(s.span,{className:"pl-c1",children:"1"}),`;
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x = ",e.exports.jsx(s.span,{className:"pl-k",children:"reinterpret_cast"}),"<",e.exports.jsx(s.span,{className:"pl-k",children:"unsigned"})," ",e.exports.jsx(s.span,{className:"pl-k",children:"long"})," ",e.exports.jsx(s.span,{className:"pl-k",children:"long"}),">(p); ",e.exports.jsx(s.span,{className:"pl-c",children:"// cast pointer back to integer"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["std::cout << x; ",e.exports.jsx(s.span,{className:"pl-c",children:"// what will you see here?"}),`
`]})]})}),`
`,e.exports.jsxs(s.p,{children:["You would probably think ",e.exports.jsx(s.code,{children:"x"})," is ",e.exports.jsx(s.code,{children:"43"}),". However depending on your hardware platform, you're likely to see ",e.exports.jsx(s.code,{children:"46"}),"! Why is that?"]}),`
`,e.exports.jsxs(s.p,{children:["If you have a pointer ",e.exports.jsx(s.code,{children:"p"})," pointing to the address of some object of type ",e.exports.jsx(s.code,{children:"T"}),", ",e.exports.jsx(s.code,{children:"p + n"})," assumes that there is an array of ",e.exports.jsx(s.code,{children:"T"}),"s stored in contiguous memory, and ",e.exports.jsx(s.code,{children:"p + n"})," evaluates to the address of the ",e.exports.jsx(s.code,{children:"n"}),"-th object after the object that ",e.exports.jsx(s.code,{children:"p"})," points to. In the above example, ",e.exports.jsx(s.code,{children:"x"})," contains the address of a (hypothetical) integer next to the (hypothetical) integer whose address is ",e.exports.jsx(s.code,{children:"42"}),". Thus, the value of ",e.exports.jsx(s.code,{children:"x"})," would be ",e.exports.jsx(s.code,{children:"42 + sizeof(int)"}),"; since ",e.exports.jsx(s.code,{children:"sizeof(int)"})," is ",e.exports.jsx(s.code,{children:"4"})," on most common hardware platforms (i.e. an integer is 4 bytes, or 32 bits), you see ",e.exports.jsx(s.code,{children:"46"})," when you print out ",e.exports.jsx(s.code,{children:"x"}),"."]}),`
`,e.exports.jsxs(s.p,{children:["You can also ",e.exports.jsx(s.em,{children:"subtract"})," integers from pointers. For example, ",e.exports.jsx(s.code,{children:"p - m"})," gives the address of the ",e.exports.jsx(s.code,{children:"m"}),"-th object before ",e.exports.jsx(s.code,{children:"*p"}),"."]}),`
`,e.exports.jsxs(s.p,{children:["Pointer arithmetic is pretty common in C/C++, and since ",e.exports.jsx(s.code,{children:"*(p + n)"})," is unwieldy to type, the language defines a syntactic sugar for us to do the exact same thing: the indexing operator ",e.exports.jsx(s.code,{children:"p[n]"})," is equivalent to ",e.exports.jsx(s.code,{children:"*(p + n)"}),"."]}),`
`,e.exports.jsxs("details",{children:[e.exports.jsx("summary",{children:"Secrets behind C-style arrays"}),e.exports.jsxs(s.p,{children:["If you have prior experience in C, you may be wondering why  our code examples typically use ",e.exports.jsx(s.code,{children:"std::array<T, N>"})," instead of the classic C-style array ",e.exports.jsx(s.code,{children:"T[N]"}),'. We made this hoice because C-style arrays have some "gotchas" that can be confusing to beginners. Consider the following example:']}),e.exports.jsx(s.pre,{className:"language-cpp",children:e.exports.jsxs(s.code,{className:"language-cpp code-highlight",children:[e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"int"})," x1[",e.exports.jsx(s.span,{className:"pl-c1",children:"3"}),"]; ",e.exports.jsx(s.span,{className:"pl-c",children:"// Declare a C-style array"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," x2 = std::array<",e.exports.jsx(s.span,{className:"pl-k",children:"int"}),", ",e.exports.jsx(s.span,{className:"pl-c1",children:"3"}),">{}; ",e.exports.jsx(s.span,{className:"pl-c",children:"// Declare a C++ std::array"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," y1 = x1; ",e.exports.jsx(s.span,{className:"pl-c",children:"// this is a pointer! not a copy of the 'x1' array!"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:[e.exports.jsx(s.span,{className:"pl-k",children:"auto"})," y2 = x2; ",e.exports.jsx(s.span,{className:"pl-c",children:"// this is a copy of the 'x2' array"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["y1[",e.exports.jsx(s.span,{className:"pl-c1",children:"0"}),"] = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),"; ",e.exports.jsx(s.span,{className:"pl-c",children:"// this is the same as 'x1[0] = 42'"}),`
`]}),e.exports.jsxs(s.span,{className:"code-line",children:["y2[",e.exports.jsx(s.span,{className:"pl-c1",children:"0"}),"] = ",e.exports.jsx(s.span,{className:"pl-c1",children:"42"}),"; ",e.exports.jsx(s.span,{className:"pl-c",children:"// this does nothing to x2, since it's a copy"}),`
`]})]})}),e.exports.jsxs(s.p,{children:[`The reason for this behavior is that C arrays automatically decay to (i.e. are converted to) the pointer to their first element.
When the compiler sees `,e.exports.jsx(s.code,{children:"x1[0]"}),", ",e.exports.jsx(s.code,{children:"x1"})," first decays to a pointer automatically, then the pointer indexing operator is invoked and then desugar-ed into ",e.exports.jsx(s.code,{children:"*(x1 + 0)"}),". Pointer arithmetic happens behind the scenes every time you manipulate a C-style array!"]})]}),`
`,e.exports.jsx(r,{})]})]})}function t(a={}){const{wrapper:s}=a.components||{};return s?e.exports.jsx(s,Object.assign({},a,{children:e.exports.jsx(n,a)})):n(a)}export{t as default,o as documentProps};
